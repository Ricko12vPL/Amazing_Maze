<!doctype html>
<html lang="pl">

<head>
  <meta charset="utf-8" />
  <title>Amazing Maze — Premium Visualizer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #050505;
      --bg-panel: rgba(20, 20, 25, 0.7);
      --glass-border: rgba(255, 255, 255, 0.08);
      --text-main: #ffffff;
      --text-muted: #a1a1aa;
      --accent-primary: #6366f1;
      /* Indigo 500 */
      --accent-glow: rgba(99, 102, 241, 0.4);
      --accent-secondary: #10b981;
      /* Emerald 500 */
      --danger: #ef4444;
      --radius-lg: 16px;
      --radius-md: 8px;
      --shadow-lg: 0 20px 50px -12px rgba(0, 0, 0, 0.9);
      --font-sans: 'Inter', sans-serif;
    }

    * {
      box-sizing: border-box;
      outline: none;
    }

    body {
      margin: 0;
      height: 100vh;
      background-color: var(--bg-dark);
      background-image:
        radial-gradient(at 0% 0%, rgba(99, 102, 241, 0.15) 0px, transparent 50%),
        radial-gradient(at 100% 100%, rgba(16, 185, 129, 0.1) 0px, transparent 50%);
      color: var(--text-main);
      font-family: var(--font-sans);
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .app-container {
      display: flex;
      width: 100%;
      height: 100%;
      max-width: 1920px;
      padding: 20px;
      gap: 24px;
    }

    /* Sidebar Panel */
    .panel {
      width: 360px;
      min-width: 320px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 24px;
      background: var(--bg-panel);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      overflow-y: auto;
      transition: transform 0.3s ease;
      z-index: 10;
    }

    .panel-header {
      border-bottom: 1px solid var(--glass-border);
      padding-bottom: 16px;
      margin-bottom: 8px;
    }

    h1 {
      margin: 0;
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #a5b4fc 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: -0.5px;
    }

    .subtitle {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 4px;
    }

    /* Controls */
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    label {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--text-muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    input[type=number],
    select {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      padding: 10px 12px;
      color: white;
      font-family: var(--font-sans);
      font-size: 14px;
      width: 100%;
      transition: all 0.2s;
    }

    input[type=number]:focus,
    select:focus {
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px var(--accent-glow);
    }

    /* Buttons */
    .btn-row {
      display: flex;
      gap: 12px;
    }

    button {
      flex: 1;
      padding: 12px;
      border: none;
      border-radius: var(--radius-md);
      font-family: var(--font-sans);
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .btn-primary {
      background: var(--accent-primary);
      color: white;
      box-shadow: 0 4px 12px var(--accent-glow);
    }

    .btn-primary:hover {
      background: #4f46e5;
      transform: translateY(-1px);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-main);
      border: 1px solid var(--glass-border);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .btn-success {
      background: var(--accent-secondary);
      color: white;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
    }

    .btn-success:hover {
      background: #059669;
    }

    /* Canvas Area */
    .canvas-wrapper {
      flex: 1;
      position: relative;
      background: rgba(0, 0, 0, 0.2);
      border-radius: var(--radius-lg);
      border: 1px solid var(--glass-border);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.5);
    }

    canvas {
      border-radius: 4px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      max-width: 95%;
      max-height: 95%;
    }

    /* Status Bar */
    .status-bar {
      margin-top: auto;
      padding-top: 16px;
      border-top: 1px solid var(--glass-border);
      font-size: 13px;
      color: var(--text-muted);
      line-height: 1.6;
    }

    .status-highlight {
      color: var(--accent-primary);
      font-weight: 600;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Mobile responsiveness */
    @media (max-width: 800px) {
      .app-container {
        flex-direction: column;
        padding: 10px;
      }

      .panel {
        width: 100%;
        height: auto;
        max-height: 40vh;
      }
    }
  </style>
</head>

<body>

  <div class="app-container">
    <aside class="panel">
      <div class="panel-header">
        <h1>Amazing Maze</h1>
        <div class="subtitle">Algorithmic Visualizer v2.0</div>
      </div>

      <div class="control-group">
        <label>Grid Size (Cell Width)</label>
        <input id="cellsInput" type="number" value="20" min="4" max="160" />
      </div>

      <div class="control-group">
        <label>Height (Rows)</label>
        <input id="rowsInput" type="number" value="40" min="6" max="200" />
      </div>

      <div class="control-group">
        <label>Shape</label>
        <select id="shapeSelect">
          <option value="rect">Rectangle</option>
          <option value="circle">Circle (Mask)</option>
        </select>
      </div>

      <div class="control-group">
        <label>Generator Algorithm</label>
        <select id="genSelect">
          <option value="dfs">Recursive Backtracker (DFS)</option>
          <option value="growing">Growing Tree (Mix)</option>
          <option value="kruskal">Kruskal (Union-Find)</option>
        </select>
      </div>

      <div class="control-group">
        <label>Growing Tree Strategy (Bias)</label>
        <input id="mixP" type="number" value="0.9" min="0" max="1" step="0.05" />
      </div>

      <div class="control-group">
        <label>Animation Speed</label>
        <input id="speed" type="number" value="2" min="0.1" max="20" step="0.5" />
      </div>

      <div class="btn-row">
        <button id="genBtn" class="btn-primary">Generate</button>
        <button id="pauseBtn" class="btn-secondary">Pause</button>
      </div>

      <div class="btn-row">
        <button id="solveBtn" class="btn-success">BFS Solve</button>
        <button id="solveAstarBtn" class="btn-success">A* Solve</button>
      </div>

      <div class="btn-row">
        <button id="addLoopsBtn" class="btn-secondary">Add Loops</button>
        <button id="exportBtn" class="btn-secondary">Export SVG</button>
      </div>

      <div class="status-bar">
        <div>Status: <span id="stats" class="status-highlight">Ready</span></div>
        <div id="metrics"></div>
        <div style="margin-top:8px; font-size:11px; opacity:0.6">
          Left Click: Start • Right Click: Goal
        </div>
      </div>
    </aside>

    <main class="canvas-wrapper">
      <canvas id="canvas"></canvas>
    </main>
  </div>

  <script>
    /**
     * PriorityQueue implementation for A*
     */
    class PriorityQueue {
      constructor(comparator = (a, b) => a > b) {
        this._heap = [];
        this._comparator = comparator;
      }
      size() { return this._heap.length; }
      isEmpty() { return this.size() === 0; }
      peek() { return this._heap[0]; }
      push(...values) {
        values.forEach(value => {
          this._heap.push(value);
          this._siftUp();
        });
        return this.size();
      }
      pop() {
        const poppedValue = this.peek();
        const bottom = this.size() - 1;
        if (bottom > 0) {
          this._heap[0] = this._heap[bottom];
        }
        this._heap.pop();
        this._siftDown();
        return poppedValue;
      }
      _parent(i) { return ((i + 1) >>> 1) - 1; }
      _left(i) { return (i << 1) + 1; }
      _right(i) { return (i + 1) << 1; }
      _greater(i, j) { return this._comparator(this._heap[i], this._heap[j]); }
      _siftUp() {
        let node = this.size() - 1;
        while (node > 0 && this._greater(node, this._parent(node))) {
          this._swap(node, this._parent(node));
          node = this._parent(node);
        }
      }
      _siftDown() {
        let node = 0;
        while (
          (this._left(node) < this.size() && this._greater(this._left(node), node)) ||
          (this._right(node) < this.size() && this._greater(this._right(node), node))
        ) {
          let maxChild = (this._right(node) < this.size() && this._greater(this._right(node), this._left(node))) ? this._right(node) : this._left(node);
          this._swap(node, maxChild);
          node = maxChild;
        }
      }
      _swap(i, j) { [this._heap[i], this._heap[j]] = [this._heap[j], this._heap[i]]; }
    }

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: false });
    const container = document.querySelector('.canvas-wrapper');

    const cellsInput = document.getElementById('cellsInput');
    const rowsInput = document.getElementById('rowsInput');
    const shapeSelect = document.getElementById('shapeSelect');
    const genSelect = document.getElementById('genSelect');
    const mixP = document.getElementById('mixP');
    const speedInput = document.getElementById('speed');

    const genBtn = document.getElementById('genBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const solveBtn = document.getElementById('solveBtn');
    const solveAstarBtn = document.getElementById('solveAstarBtn');
    const addLoopsBtn = document.getElementById('addLoopsBtn');
    const exportBtn = document.getElementById('exportBtn');

    const statsEl = document.getElementById('stats');
    const metricsEl = document.getElementById('metrics');

    let maze = null;
    let paused = false;
    let cellSize = 20;
    let startGrid = null;
    let goalGrid = null;
    let abortController = null;

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function rng() { return Math.random(); }

    class Maze {
      constructor(w, h, maskFunc = null) {
        this.w = w; this.h = h;
        this.grid_h = 2 * h + 1; this.grid_w = 2 * w + 1;
        this.grid = new Int8Array(this.grid_h * this.grid_w).fill(1);
        this.mask = maskFunc;
        this.cells = [];
        for (let r = 0; r < h; r++) {
          for (let c = 0; c < w; c++) {
            if (!this.mask || this.mask(r, c)) {
              const gr = r * 2 + 1, gc = c * 2 + 1;
              this.set(gr, gc, 0);
              this.cells.push([r, c]);
            }
          }
        }
      }
      get(r, c) { return this.grid[r * this.grid_w + c]; }
      set(r, c, val) { this.grid[r * this.grid_w + c] = val; }

      inBoundsCell(r, c) { return r >= 0 && r < this.h && c >= 0 && c < this.w && (!this.mask || this.mask(r, c)); }
      cellToGrid(r, c) { return [r * 2 + 1, c * 2 + 1]; }
      removeWallBetween(a, b) {
        const [ar, ac] = a, [br, bc] = b;
        const [gar, gac] = this.cellToGrid(ar, ac), [gbr, gbc] = this.cellToGrid(br, bc);
        const wr = (gar + gbr) >> 1, wc = (gac + gbc) >> 1;
        this.set(wr, wc, 0);
      }
    }

    // Drawing
    function drawMaze(m, highlightSet = null, path = null) {
      if (!m) return;
      const H = m.grid_h, W = m.grid_w;

      const availW = container.clientWidth;
      const availH = container.clientHeight;
      const pad = 20;

      const maxCellW = Math.floor((availW - pad * 2) / W);
      const maxCellH = Math.floor((availH - pad * 2) / H);
      cellSize = Math.max(2, Math.min(Number(cellsInput.value), maxCellW, maxCellH));

      const drawW = W * cellSize;
      const drawH = H * cellSize;

      if (canvas.width !== drawW || canvas.height !== drawH) {
        canvas.width = drawW;
        canvas.height = drawH;
      }

      // Colors
      const COLOR_BG = '#050505';
      const COLOR_WALL = '#0f172a'; // Slate 900
      const COLOR_PASSAGE = '#e2e8f0'; // Slate 200
      const COLOR_HIGHLIGHT = 'rgba(99, 102, 241, 0.5)'; // Indigo
      const COLOR_PATH = '#ef4444'; // Red
      const COLOR_START = '#10b981'; // Emerald
      const COLOR_GOAL = '#3b82f6'; // Blue

      ctx.fillStyle = COLOR_WALL;
      ctx.fillRect(0, 0, drawW, drawH);

      ctx.fillStyle = COLOR_PASSAGE;
      for (let r = 0; r < H; r++) {
        for (let c = 0; c < W; c++) {
          if (m.get(r, c) === 0) {
            ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
          }
        }
      }

      if (highlightSet) {
        ctx.fillStyle = COLOR_HIGHLIGHT;
        for (const k of highlightSet) {
          const [r, c] = k.split(',').map(Number);
          ctx.fillRect(c * cellSize, r * cellSize, cellSize, cellSize);
        }
      }

      if (path) {
        ctx.fillStyle = COLOR_PATH;
        const inset = cellSize * 0.25;
        const size = cellSize - inset * 2;
        for (const [r, c] of path) {
          ctx.fillRect(c * cellSize + inset, r * cellSize + inset, size, size);
        }
      }

      if (startGrid) {
        const [sr, sc] = startGrid;
        ctx.fillStyle = COLOR_START;
        ctx.fillRect(sc * cellSize, sr * cellSize, cellSize, cellSize);
      }
      if (goalGrid) {
        const [gr, gc] = goalGrid;
        ctx.fillStyle = COLOR_GOAL;
        ctx.fillRect(gc * cellSize, gr * cellSize, cellSize, cellSize);
      }
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
    }

    async function throttle(speedFactor) {
      if (speedFactor > 10) return;
      const base = 20;
      const ms = base / speedFactor;
      await sleep(ms);
    }

    /* ====== GENERATORS ====== */

    async function generateDFS_fullcoverage(m, speedFactor = 1, strategy = 'last') {
      statsEl.textContent = 'Generating (DFS)...';
      const visited = new Set();
      if (!m || m.cells.length === 0) return;

      const keyOf = (cell) => `${cell[0]},${cell[1]}`;

      let unvisitedList = [...m.cells];
      shuffle(unvisitedList);

      let startCell = unvisitedList.pop();
      const stack = [startCell];
      visited.add(keyOf(startCell));
      const highlights = new Set();

      while ((stack.length > 0 || unvisitedList.length > 0) && !paused) {
        if (abortController && abortController.signal.aborted) return;

        if (stack.length === 0) {
          let next = null;
          while (unvisitedList.length > 0) {
            const candidate = unvisitedList.pop();
            if (!visited.has(keyOf(candidate))) {
              next = candidate;
              break;
            }
          }

          if (!next) break;

          const nbrsVisited = [];
          for (const d of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
            const nr = next[0] + d[0], nc = next[1] + d[1];
            if (m.inBoundsCell(nr, nc) && visited.has(`${nr},${nc}`)) {
              nbrsVisited.push([nr, nc]);
            }
          }

          if (nbrsVisited.length > 0) {
            const chosen = nbrsVisited[Math.floor(rng() * nbrsVisited.length)];
            m.removeWallBetween(chosen, next);
            visited.add(keyOf(next));
            stack.push(next);
            highlights.add(keyOf(next));
          } else {
            visited.add(keyOf(next));
            stack.push(next);
          }

          drawMaze(m, highlights);
          await throttle(speedFactor);
          continue;
        }

        let idx;
        if (typeof strategy === 'number') {
          idx = (rng() < strategy) ? stack.length - 1 : Math.floor(rng() * stack.length);
        } else if (strategy === 'last') idx = stack.length - 1;
        else if (strategy === 'random') idx = Math.floor(rng() * stack.length);
        else idx = stack.length - 1;

        const cell = stack[idx];
        const [r, c] = cell;

        const neighbors = [];
        for (const d of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
          const nr = r + d[0], nc = c + d[1];
          if (m.inBoundsCell(nr, nc) && !visited.has(`${nr},${nc}`)) {
            neighbors.push([nr, nc]);
          }
        }

        if (neighbors.length > 0) {
          const nb = neighbors[Math.floor(rng() * neighbors.length)];
          m.removeWallBetween([r, c], nb);
          visited.add(keyOf(nb));
          stack.push(nb);
          highlights.add(keyOf(nb));
          highlights.add(keyOf([r, c]));
        } else {
          stack.splice(idx, 1);
        }

        if (Math.random() < 0.1) {
          drawMaze(m, highlights);
          await throttle(speedFactor);
        }
      }

      drawMaze(m);
      statsEl.textContent = 'Generated (DFS)';
    }

    async function generateKruskal(m, speedFactor = 1) {
      statsEl.textContent = 'Generating (Kruskal)...';
      const edges = [];
      for (const [r, c] of m.cells) {
        [[0, 1], [1, 0]].forEach(d => {
          const nr = r + d[0], nc = c + d[1];
          if (m.inBoundsCell(nr, nc)) edges.push([[r, c], [nr, nc]]);
        });
      }
      shuffle(edges);

      const parent = new Int32Array(m.h * m.w).fill(-1);
      const cellIndex = (r, c) => r * m.w + c;

      function find(i) {
        if (parent[i] < 0) return i;
        parent[i] = find(parent[i]);
        return parent[i];
      }
      function union(i, j) {
        const rootI = find(i);
        const rootJ = find(j);
        if (rootI === rootJ) return false;
        parent[rootJ] = rootI;
        return true;
      }

      const highlights = new Set();
      let batchSize = Math.max(1, Math.floor(edges.length / 200));

      for (let i = 0; i < edges.length; i++) {
        if (abortController && abortController.signal.aborted) return;
        if (paused) { await sleep(100); i--; continue; }

        const [a, b] = edges[i];
        const idxA = cellIndex(a[0], a[1]);
        const idxB = cellIndex(b[0], b[1]);

        if (union(idxA, idxB)) {
          m.removeWallBetween(a, b);
          highlights.add(`${a[0]},${a[1]}`);
          highlights.add(`${b[0]},${b[1]}`);
        }

        if (i % batchSize === 0) {
          drawMaze(m, highlights);
          highlights.clear();
          await throttle(speedFactor);
        }
      }
      drawMaze(m);
      statsEl.textContent = 'Generated (Kruskal)';
    }

    /* ====== SOLVERS ====== */

    async function bfsSolve(m, speedFactor = 1) {
      if (!m || !startGrid || !goalGrid) return;
      statsEl.textContent = 'Solving (BFS)...';

      const H = m.grid_h, W = m.grid_w;
      const start = startGrid, goal = goalGrid;

      const q = [start];
      let head = 0;

      const parent = new Int32Array(H * W).fill(-1);
      const visited = new Int8Array(H * W).fill(0);

      const flatIdx = (r, c) => r * W + c;
      const unFlatIdx = (idx) => [Math.floor(idx / W), idx % W];

      const startFlat = flatIdx(start[0], start[1]);
      visited[startFlat] = 1;

      const highlights = new Set();
      let found = false;

      while (head < q.length && !paused) {
        if (abortController && abortController.signal.aborted) return;

        const cur = q[head++];
        const [r, c] = cur;

        if (r === goal[0] && c === goal[1]) { found = true; break; }

        const curFlat = flatIdx(r, c);

        for (const d of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
          const nr = r + d[0], nc = c + d[1];
          if (nr >= 0 && nr < H && nc >= 0 && nc < W && m.get(nr, nc) === 0) {
            const nFlat = flatIdx(nr, nc);
            if (visited[nFlat] === 0) {
              visited[nFlat] = 1;
              parent[nFlat] = curFlat;
              q.push([nr, nc]);
              highlights.add(`${nr},${nc}`);
            }
          }
        }

        if (head % 50 === 0) {
          drawMaze(m, highlights);
          await throttle(speedFactor);
        }
      }

      if (!found) { statsEl.textContent = 'No Path Found'; return; }

      const path = [];
      let curr = flatIdx(goal[0], goal[1]);
      while (curr !== -1 && curr !== startFlat) {
        path.push(unFlatIdx(curr));
        curr = parent[curr];
      }
      path.push(start);
      path.reverse();

      statsEl.textContent = `Solved (BFS): ${path.length} steps`;
      drawMaze(m, null, path);
    }

    function heuristic(r, c, gr, gc) { return Math.abs(r - gr) + Math.abs(c - gc); }

    async function aStarSolve(m, speedFactor = 1) {
      if (!m || !startGrid || !goalGrid) return;
      statsEl.textContent = 'Solving (A*)...';

      const H = m.grid_h, W = m.grid_w;
      const [sr, sc] = startGrid;
      const [gr, gc] = goalGrid;

      const pq = new PriorityQueue((a, b) => a[0] < b[0]);
      pq.push([0, sr, sc]);

      const flatIdx = (r, c) => r * W + c;
      const gScore = new Float32Array(H * W).fill(Infinity);
      const parent = new Int32Array(H * W).fill(-1);

      const startFlat = flatIdx(sr, sc);
      gScore[startFlat] = 0;

      const highlights = new Set();
      let found = false;

      while (!pq.isEmpty() && !paused) {
        if (abortController && abortController.signal.aborted) return;

        const [f, r, c] = pq.pop();

        if (r === gr && c === gc) { found = true; break; }

        const currentFlat = flatIdx(r, c);
        const currentG = gScore[currentFlat];

        for (const d of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
          const nr = r + d[0], nc = c + d[1];
          if (nr >= 0 && nr < H && nc >= 0 && nc < W && m.get(nr, nc) === 0) {
            const tentativeG = currentG + 1;
            const nFlat = flatIdx(nr, nc);

            if (tentativeG < gScore[nFlat]) {
              parent[nFlat] = currentFlat;
              gScore[nFlat] = tentativeG;
              const h = heuristic(nr, nc, gr, gc);
              pq.push([tentativeG + h, nr, nc]);
              highlights.add(`${nr},${nc}`);
            }
          }
        }

        if (Math.random() < 0.05) {
          drawMaze(m, highlights);
          await throttle(speedFactor);
        }
      }

      if (!found) { statsEl.textContent = 'No Path Found (A*)'; return; }

      const path = [];
      let curr = flatIdx(gr, gc);
      while (curr !== -1) {
        const [rr, cc] = [Math.floor(curr / W), curr % W];
        path.push([rr, cc]);
        if (rr === sr && cc === sc) break;
        curr = parent[curr];
      }
      path.reverse();

      statsEl.textContent = `Solved (A*): ${path.length} steps`;
      drawMaze(m, null, path);
    }

    /* ====== UTILS ====== */
    function addLoops(m, percent = 0.05) {
      const H = m.grid_h, W = m.grid_w;
      let removed = 0;
      for (let r = 1; r < H - 1; r++) {
        for (let c = 1; c < W - 1; c++) {
          if (m.get(r, c) === 1 && Math.random() < percent) {
            const neighPass = (m.get(r - 1, c) === 0) + (m.get(r + 1, c) === 0) + (m.get(r, c - 1) === 0) + (m.get(r, c + 1) === 0);
            if (neighPass >= 2) {
              m.set(r, c, 0); removed++;
            }
          }
        }
      }
      return removed;
    }

    function exportSVG(m) {
      if (!m) return;
      const H = m.grid_h, W = m.grid_w;
      const cs = 10;
      const width = W * cs, height = H * cs;
      let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`;
      svg += `<rect width="100%" height="100%" fill="#050505"/>`;
      for (let r = 0; r < H; r++) {
        for (let c = 0; c < W; c++) {
          if (m.get(r, c) === 1) {
            svg += `<rect x="${c * cs}" y="${r * cs}" width="${cs}" height="${cs}" fill="#0f172a"/>`;
          }
        }
      }
      svg += `</svg>`;
      const blob = new Blob([svg], { type: 'image/svg+xml' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'maze.svg'; document.body.appendChild(a); a.click(); a.remove();
      URL.revokeObjectURL(url);
    }

    /* ====== CONTROLS ====== */

    async function runTask(taskFn) {
      if (abortController) abortController.abort();
      abortController = new AbortController();
      paused = false;
      pauseBtn.textContent = 'Pause';
      try {
        await taskFn();
      } catch (e) {
        console.log("Task aborted or error", e);
      }
    }

    genBtn.addEventListener('click', () => runTask(startGeneration));
    pauseBtn.addEventListener('click', () => {
      paused = !paused;
      pauseBtn.textContent = paused ? 'Resume' : 'Pause';
    });
    solveBtn.addEventListener('click', () => runTask(() => bfsSolve(maze, Number(speedInput.value))));
    solveAstarBtn.addEventListener('click', () => runTask(() => aStarSolve(maze, Number(speedInput.value))));
    addLoopsBtn.addEventListener('click', () => { if (maze) { addLoops(maze); drawMaze(maze); } });
    exportBtn.addEventListener('click', () => { if (maze) exportSVG(maze); });

    canvas.addEventListener('mousedown', (ev) => {
      if (!maze) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;

      const x = (ev.clientX - rect.left) * scaleX;
      const y = (ev.clientY - rect.top) * scaleY;

      const gc = Math.floor(x / cellSize);
      const gr = Math.floor(y / cellSize);

      if (gr >= 0 && gr < maze.grid_h && gc >= 0 && gc < maze.grid_w && maze.get(gr, gc) === 0) {
        // Right click (2) or Ctrl+Click for Goal
        if (ev.button === 2 || ev.ctrlKey) {
          goalGrid = [gr, gc];
        } else {
          startGrid = [gr, gc];
        }
        drawMaze(maze);
      }
    });
    canvas.addEventListener('contextmenu', e => e.preventDefault());

    window.addEventListener('resize', () => {
      if (maze) drawMaze(maze);
    });

    async function startGeneration() {
      const w = Number(cellsInput.value) | 0;
      const h = Number(rowsInput.value) | 0;
      let mask = null;
      if (shapeSelect.value === 'circle') {
        const cx = (w - 1) / 2, cy = (h - 1) / 2, rad = Math.min(w, h) / 2 - 0.5;
        mask = (r, c) => {
          const dx = c - cx, dy = r - cy;
          return (dx * dx + dy * dy) <= (rad * rad);
        };
      }

      maze = new Maze(w, h, mask);
      startGrid = null; goalGrid = null;
      drawMaze(maze);

      const speedFactor = Number(speedInput.value) || 1;
      const gen = genSelect.value;

      if (gen === 'dfs' || gen === 'growing') {
        const strategy = (gen === 'growing') ? Number(mixP.value) : 'last';
        await generateDFS_fullcoverage(maze, speedFactor, strategy);
      } else if (gen === 'kruskal') {
        await generateKruskal(maze, speedFactor);
      }

      let s = null, g = null;
      for (let r = 1; r < maze.grid_h - 1; r++) {
        for (let c = 1; c < maze.grid_w - 1; c++) {
          if (maze.get(r, c) === 0) {
            if (!s) s = [r, c];
            g = [r, c];
          }
        }
      }
      startGrid = s;
      goalGrid = g;
      drawMaze(maze);

      const total = maze.cells.length;
      statsEl.textContent = `Ready. Cells: ${total}`;
    }

    window.addEventListener('load', () => runTask(startGeneration));

  </script>
</body>

</html>