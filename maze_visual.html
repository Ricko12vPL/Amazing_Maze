<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>THE MAZE // MATRIX EDITION</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
  <!-- Three.js CDN -->
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
    }
  }
</script>
  <style>
    :root {
      --bg-color: #000000;
      --matrix-green: #00ff41;
      --matrix-dark: #003b00;
      --glass-border: rgba(0, 255, 65, 0.3);
      --font-main: 'VT323', monospace;
    }

    * {
      box-sizing: border-box;
      outline: none;
      user-select: none;
    }

    body {
      margin: 0;
      height: 100vh;
      background-color: var(--bg-color);
      color: var(--matrix-green);
      font-family: var(--font-main);
      overflow: hidden;
      font-size: 18px;
    }

    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* 3D Canvas Layer */
    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      background: transparent;
      /* Was #000 */
    }

    /* UI Layer */
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      display: flex;
      padding: 20px;
      gap: 20px;
    }

    /* Terminal Panel */
    .panel {
      pointer-events: auto;
      width: 360px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid var(--matrix-green);
      box-shadow: 0 0 15px var(--matrix-dark);
      overflow-y: auto;
      max-height: 100%;
      transition: transform 0.3s ease;
    }

    .panel.collapsed {
      transform: translateX(-380px);
    }

    .panel-header {
      border-bottom: 1px dashed var(--matrix-green);
      padding-bottom: 10px;
      margin-bottom: 10px;
      text-align: center;
    }

    h1 {
      margin: 0;
      font-size: 32px;
      font-weight: 400;
      text-shadow: 0 0 5px var(--matrix-green);
      letter-spacing: 2px;
    }

    .blink {
      animation: blinker 1s linear infinite;
    }

    @keyframes blinker {
      50% {
        opacity: 0;
      }
    }

    /* Controls */
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    label {
      font-size: 16px;
      text-transform: uppercase;
      color: var(--matrix-green);
      opacity: 0.8;
    }

    input,
    select {
      background: #000;
      border: 1px solid var(--matrix-dark);
      color: var(--matrix-green);
      font-family: var(--font-main);
      font-size: 18px;
      padding: 8px;
      width: 100%;
      text-transform: uppercase;
    }

    input:focus,
    select:focus {
      border-color: var(--matrix-green);
      box-shadow: 0 0 8px var(--matrix-dark);
    }

    /* Buttons */
    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button {
      padding: 10px;
      background: #000;
      border: 1px solid var(--matrix-green);
      color: var(--matrix-green);
      font-family: var(--font-main);
      font-size: 18px;
      cursor: pointer;
      text-transform: uppercase;
      transition: all 0.2s;
    }

    button:hover {
      background: var(--matrix-green);
      color: #000;
      box-shadow: 0 0 10px var(--matrix-green);
    }

    button:active {
      transform: translateY(2px);
    }

    /* Stats Panel */
    .stats-panel {
      pointer-events: auto;
      position: absolute;
      top: 20px;
      right: 20px;
      width: 280px;
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid var(--matrix-green);
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-family: var(--font-main);
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      border-bottom: 1px dotted var(--matrix-dark);
      padding-bottom: 4px;
    }

    .stat-val {
      font-weight: bold;
      text-shadow: 0 0 2px var(--matrix-green);
    }

    /* Game Overlay */
    #game-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: none;
      pointer-events: auto;
      background: #000;
      border: 2px solid var(--matrix-green);
      padding: 40px;
      box-shadow: 0 0 30px var(--matrix-green);
    }

    .game-msg {
      font-size: 64px;
      color: var(--matrix-green);
      text-shadow: 0 0 10px var(--matrix-green);
      margin-bottom: 20px;
    }

    /* Toggle Button */
    .toggle-panel-btn {
      pointer-events: auto;
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      border: 1px solid var(--matrix-green);
      background: #000;
      color: var(--matrix-green);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      z-index: 20;
    }

    /* Matrix Rain Canvas (Optional BG) */
    #matrix-bg {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      opacity: 0.15;
      pointer-events: none;
    }
  </style>
</head>

<body>

  <canvas id="matrix-bg"></canvas>

  <div id="app">
    <div id="canvas-container"></div>

    <div id="ui-layer">
      <aside class="panel" id="mainPanel">
        <div class="panel-header">
          <h1>SYSTEM_ROOT<span class="blink">_</span></h1>
          <div style="font-size:14px; opacity:0.7">v4.0.1 [MATRIX_BUILD]</div>
        </div>

        <div class="control-group">
          <label>> VIEW_MODE</label>
          <div class="btn-grid">
            <button id="viewOrbit">ORBIT_CAM</button>
            <button id="viewFPS">NEO_MODE</button>
          </div>
        </div>

        <div class="control-group">
          <label>> GRID_SIZE</label>
          <div style="display:flex; gap:10px">
            <input id="widthInput" type="number" value="30" min="5" max="200" placeholder="W">
            <input id="heightInput" type="number" value="30" min="5" max="200" placeholder="H">
          </div>
        </div>

        <div class="control-group">
          <label>> SHAPE_MASK</label>
          <select id="shapeSelect">
            <option value="rect">RECTANGLE</option>
            <option value="circle">CIRCLE</option>
            <option value="triangle">TRIANGLE</option>
            <option value="donut">DONUT</option>
          </select>
        </div>

        <div class="control-group">
          <label>> ALGORITHM</label>
          <select id="genSelect">
            <option value="dfs">DFS_BACKTRACK</option>
            <option value="kruskal">KRUSKAL_SET</option>
            <option value="prim">PRIM_MST</option>
            <option value="wilson">WILSON_LERW</option>
            <option value="growing">GROWING_TREE</option>
            <option value="caves">CELL_AUTOMATA</option>
          </select>
        </div>

        <div class="control-group">
          <label>> EXEC_SPEED</label>
          <input id="speedInput" type="number" value="5" min="1" max="50">
        </div>

        <div class="btn-grid">
          <button id="genBtn">INITIALIZE</button>
          <button id="stopBtn" style="border-color:#f00; color:#f00">ABORT</button>
        </div>

        <hr style="border:0; border-top:1px dashed var(--matrix-dark); width:100%; margin:10px 0;">

        <div class="control-group">
          <label>> SOLVER_PROTOCOL</label>
          <select id="solveSelect">
            <option value="bfs">BFS_SHORTEST</option>
            <option value="bibfs">BIDIRECTIONAL</option>
            <option value="astar">A_STAR_HEURISTIC</option>
            <option value="dijkstra">DIJKSTRA_COST</option>
          </select>
        </div>

        <div class="btn-grid">
          <button id="solveBtn">CALCULATE</button>
          <button id="heatmapBtn">HEAT_MAP</button>
        </div>

        <button id="clearBtn" style="margin-top:10px">PURGE_DATA</button>

        <div style="margin-top:auto; font-size:14px; opacity:0.6; line-height:1.4">
          > CONTROLS_INIT:<br>
          [LMB] ROTATE / [RMB] PAN<br>
          [WASD] LOCOMOTION [SHIFT] SPRINT
        </div>
      </aside>

      <div class="stats-panel">
        <div class="stat-row">
          <span>STATUS:</span>
          <span class="stat-val" id="statusVal">IDLE</span>
        </div>
        <div class="stat-row">
          <span>NODES:</span>
          <span class="stat-val" id="cellsVal">0</span>
        </div>
        <div class="stat-row">
          <span>DEAD_ENDS:</span>
          <span class="stat-val" id="deadEndsVal">0%</span>
        </div>
        <div class="stat-row">
          <span>PATH_LEN:</span>
          <span class="stat-val" id="pathLenVal">-</span>
        </div>
        <div class="stat-row">
          <span>VISITED:</span>
          <span class="stat-val" id="visitedVal">0</span>
        </div>
      </div>

      <div id="game-overlay">
        <div class="game-msg" id="gameMsg">SYSTEM_HACKED</div>
        <button onclick="exitGameMode()">JACK_OUT</button>
      </div>

      <button class="toggle-panel-btn" id="togglePanelBtn">></button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    // MeshLine import removed as it caused loading errors. Using TubeGeometry instead.

    // --- CONFIG ---
    const WALL_HEIGHT = 1.2;
    const CELL_SIZE = 1;

    // --- STATE ---
    let maze = null;
    let scene, camera, renderer, controls, fpsControls;
    let wallInstancedMesh, floorInstancedMesh;
    let pathMeshGroup = new THREE.Group();
    let isGameMode = false;
    let abortController = null;
    let isGenerating = false;

    // --- DOM ---
    const ui = {
      width: document.getElementById('widthInput'),
      height: document.getElementById('heightInput'),
      shape: document.getElementById('shapeSelect'),
      genSelect: document.getElementById('genSelect'),
      solveSelect: document.getElementById('solveSelect'),
      speed: document.getElementById('speedInput'),
      status: document.getElementById('statusVal'),
      cells: document.getElementById('cellsVal'),
      deadEnds: document.getElementById('deadEndsVal'),
      pathLen: document.getElementById('pathLenVal'),
      visited: document.getElementById('visitedVal'),
      gameOverlay: document.getElementById('game-overlay'),
      gameMsg: document.getElementById('gameMsg')
    };

    // --- MAZE DATA STRUCTURE ---
    class Maze {
      constructor(w, h, shape = 'rect') {
        this.w = w; this.h = h;
        this.gw = 2 * w + 1;
        this.gh = 2 * h + 1;
        this.data = new Int8Array(this.gw * this.gh).fill(1); // 1=Wall, 0=Passage
        this.shape = shape;

        // Apply Mask
        this.applyMask();

        // Collect valid cells
        this.cells = [];
        for (let r = 0; r < h; r++) {
          for (let c = 0; c < w; c++) {
            if (this.isValid(r, c)) this.cells.push([r, c]);
          }
        }
      }

      get(r, c) { return this.data[r * this.gw + c]; }
      set(r, c, v) { this.data[r * this.gw + c] = v; }
      toGrid(r, c) { return [r * 2 + 1, c * 2 + 1]; }

      isValid(r, c) {
        const gr = r * 2 + 1;
        const gc = c * 2 + 1;
        return this.data[gr * this.gw + gc] !== -1; // -1 is masked
      }

      applyMask() {
        const cx = this.gw / 2;
        const cy = this.gh / 2;

        for (let r = 0; r < this.gh; r++) {
          for (let c = 0; c < this.gw; c++) {
            let masked = false;
            if (this.shape === 'circle') {
              const dx = c - cx;
              const dy = r - cy;
              if (dx * dx + dy * dy > (Math.min(this.gw, this.gh) / 2) ** 2) masked = true;
            } else if (this.shape === 'triangle') {
              // Simple triangle: c <= r (scaled)
              // Let's do an isosceles pointing up
              // y from 0 to h. x from w/2 - y/2 to w/2 + y/2
              const py = r;
              const h = this.gh;
              const w = this.gw;
              const halfW = (py / h) * (w / 2);
              if (c < cx - halfW || c > cx + halfW) masked = true;
            } else if (this.shape === 'donut') {
              const dx = c - cx;
              const dy = r - cy;
              const distSq = dx * dx + dy * dy;
              const maxR = (Math.min(this.gw, this.gh) / 2);
              const minR = maxR * 0.4;
              if (distSq > maxR ** 2 || distSq < minR ** 2) masked = true;
            }

            if (masked) this.data[r * this.gw + c] = -1;
          }
        }
      }

      removeWall(c1, c2) {
        const [r1, c1x] = c1;
        const [r2, c2x] = c2;
        const [gr1, gc1] = this.toGrid(r1, c1x);
        const [gr2, gc2] = this.toGrid(r2, c2x);

        this.set(gr1, gc1, 0);
        this.set(gr2, gc2, 0);
        this.set((gr1 + gr2) >> 1, (gc1 + gc2) >> 1, 0);
      }

      inBounds(r, c) {
        return r >= 0 && r < this.h && c >= 0 && c < this.w && this.isValid(r, c);
      }
    }

    // --- 3D ENGINE ---
    function init3D() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = null; // Transparent to show Matrix Rain
      // scene.fog = new THREE.FogExp2(0x000500, 0.015); // Fog removed for clarity

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 40, 40);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // Alpha enabled
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x000000, 0); // Clear transparent
      container.appendChild(renderer.domElement);

      // Matrix Lighting - Boosted
      const ambient = new THREE.AmbientLight(0x00ff41, 0.4); // Increased from 0.1
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0x00ff41, 1.5); // Increased from 0.8
      dirLight.position.set(10, 50, 20);
      scene.add(dirLight);

      // Backlight for better depth
      const backLight = new THREE.DirectionalLight(0x004400, 1.0);
      backLight.position.set(-10, 20, -20);
      scene.add(backLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      fpsControls = new PointerLockControls(camera, document.body);
      fpsControls.addEventListener('lock', () => { isGameMode = true; });
      fpsControls.addEventListener('unlock', () => { });

      scene.add(pathMeshGroup);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      initMatrixRain();
      animate();
    }

    // Matrix Rain Effect
    const canvas = document.getElementById('matrix-bg');
    const ctx = canvas.getContext('2d');
    let drops = [];
    function initMatrixRain() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      const columns = canvas.width / 20;
      drops = Array(Math.floor(columns)).fill(1);
    }
    function drawMatrixRain() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#00ff41';
      ctx.font = '15px monospace';
      for (let i = 0; i < drops.length; i++) {
        const text = String.fromCharCode(0x30A0 + Math.random() * 96);
        ctx.fillText(text, i * 20, drops[i] * 20);
        if (drops[i] * 20 > canvas.height && Math.random() > 0.975) drops[i] = 0;
        drops[i]++;
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      drawMatrixRain();

      if (isGameMode) updateGameLogic();
      else controls.update();

      renderer.render(scene, camera);
    }

    // --- RENDERING MAZE ---
    function renderMazeFull(m) {
      if (wallInstancedMesh) scene.remove(wallInstancedMesh);
      if (floorInstancedMesh) scene.remove(floorInstancedMesh);

      // Wall: Wireframe-ish look - Brighter
      const wallGeo = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
      const wallMat = new THREE.MeshPhongMaterial({
        color: 0x002200, // Brighter base
        emissive: 0x004400, // Brighter emission
        specular: 0x00ff41,
        shininess: 40,
        transparent: true,
        opacity: 0.85
      });

      // Floor: Grid tiles - Visible grid
      const floorGeo = new THREE.PlaneGeometry(CELL_SIZE * 0.9, CELL_SIZE * 0.9);
      const floorMat = new THREE.MeshBasicMaterial({ color: 0x002200 }); // Brighter floor

      let wallCount = 0;
      let floorCount = 0;

      for (let i = 0; i < m.data.length; i++) {
        if (m.data[i] === 1) wallCount++;
        else if (m.data[i] === 0) floorCount++;
      }

      wallInstancedMesh = new THREE.InstancedMesh(wallGeo, wallMat, wallCount);
      floorInstancedMesh = new THREE.InstancedMesh(floorGeo, floorMat, floorCount);

      const dummy = new THREE.Object3D();
      let wIdx = 0, fIdx = 0;
      const offsetX = -(m.gw * CELL_SIZE) / 2;
      const offsetZ = -(m.gh * CELL_SIZE) / 2;

      // Map grid index to instance index for coloring later
      m.floorMap = new Map();

      for (let r = 0; r < m.gh; r++) {
        for (let c = 0; c < m.gw; c++) {
          const val = m.data[r * m.gw + c];
          if (val === 1) {
            dummy.position.set(c * CELL_SIZE + offsetX, WALL_HEIGHT / 2, r * CELL_SIZE + offsetZ);
            dummy.rotation.set(0, 0, 0);
            dummy.updateMatrix();
            wallInstancedMesh.setMatrixAt(wIdx++, dummy.matrix);
          } else if (val === 0) {
            dummy.position.set(c * CELL_SIZE + offsetX, 0, r * CELL_SIZE + offsetZ);
            dummy.rotation.set(-Math.PI / 2, 0, 0);
            dummy.updateMatrix();
            floorInstancedMesh.setMatrixAt(fIdx, dummy.matrix);
            m.floorMap.set(`${r},${c}`, fIdx);
            fIdx++;
          }
        }
      }

      scene.add(wallInstancedMesh);
      scene.add(floorInstancedMesh);

      if (!isGameMode) {
        controls.target.set(0, 0, 0);
        camera.position.set(0, Math.max(m.gw, m.gh) * 1.0, Math.max(m.gw, m.gh) * 0.8);
        controls.update();
      }
    }

    // --- ALGORITHMS ---
    async function runTask(fn) {
      if (abortController) abortController.abort();
      abortController = new AbortController();
      isGenerating = true;
      ui.status.innerText = "EXECUTING...";
      try {
        await fn(abortController.signal);
        ui.status.innerText = "COMPLETED";
      } catch (e) {
        if (e.name === 'AbortError') ui.status.innerText = "TERMINATED";
        else console.error(e);
      }
      isGenerating = false;
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function rng() { return Math.random(); }

    // Generators
    async function generateMaze(signal) {
      const w = parseInt(ui.width.value);
      const h = parseInt(ui.height.value);
      const shape = ui.shape.value;
      maze = new Maze(w, h, shape);

      renderMazeFull(maze);

      const algo = ui.genSelect.value;
      const speed = parseInt(ui.speed.value);

      let batch = 0;
      const updateVis = async () => {
        if (batch++ % speed === 0) {
          renderMazeFull(maze);
          await sleep(10);
        }
      };

      if (algo === 'dfs') await genDFS(maze, updateVis, signal);
      else if (algo === 'kruskal') await genKruskal(maze, updateVis, signal);
      else if (algo === 'prim') await genPrim(maze, updateVis, signal);
      else if (algo === 'wilson') await genWilson(maze, updateVis, signal);
      else if (algo === 'growing') await genGrowing(maze, updateVis, signal);
      else if (algo === 'caves') await genCaves(maze, updateVis, signal);

      renderMazeFull(maze);
      calcStats(maze);
    }

    // (Reuse existing generator logic but updated for mask)
    async function genDFS(m, update, signal) {
      // Find valid start
      let start = null;
      for (const c of m.cells) { start = c; break; }
      if (!start) return;

      const stack = [start];
      const visited = new Set([`${start[0]},${start[1]}`]);
      m.set(m.toGrid(start[0], start[1])[0], m.toGrid(start[0], start[1])[1], 0);

      while (stack.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        const [r, c] = stack[stack.length - 1];
        const nbrs = [];
        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
          const nr = r + dr, nc = c + dc;
          if (m.inBounds(nr, nc) && !visited.has(`${nr},${nc}`)) nbrs.push([nr, nc]);
        });

        if (nbrs.length > 0) {
          const [nr, nc] = nbrs[Math.floor(rng() * nbrs.length)];
          m.removeWall([r, c], [nr, nc]);
          visited.add(`${nr},${nc}`);
          stack.push([nr, nc]);
          await update();
        } else {
          stack.pop();
        }
      }
    }

    // ... (Other generators similar, just ensure m.inBounds checks mask)
    async function genPrim(m, update, signal) {
      let start = null;
      for (const c of m.cells) { start = c; break; }
      if (!start) return;

      const walls = [];
      const visited = new Set([`${start[0]},${start[1]}`]);
      const [sr, sc] = m.toGrid(start[0], start[1]);
      m.set(sr, sc, 0);

      [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
        const nr = start[0] + dr, nc = start[1] + dc;
        if (m.inBounds(nr, nc)) walls.push([start, [nr, nc]]);
      });

      while (walls.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        const idx = Math.floor(rng() * walls.length);
        const [p, n] = walls[idx];
        walls.splice(idx, 1);
        const nKey = `${n[0]},${n[1]}`;
        if (!visited.has(nKey)) {
          m.removeWall(p, n);
          visited.add(nKey);
          [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
            const nr = n[0] + dr, nc = n[1] + dc;
            if (m.inBounds(nr, nc) && !visited.has(`${nr},${nc}`)) walls.push([n, [nr, nc]]);
          });
          await update();
        }
      }
    }

    async function genWilson(m, update, signal) {
      const unvisited = new Set(m.cells.map(c => `${c[0]},${c[1]}`));
      const firstKey = [...unvisited][Math.floor(rng() * unvisited.size)];
      unvisited.delete(firstKey);
      const [fr, fc] = firstKey.split(',').map(Number);
      const [gfr, gfc] = m.toGrid(fr, fc);
      m.set(gfr, gfc, 0);

      while (unvisited.size > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        let u = [...unvisited][Math.floor(rng() * unvisited.size)];
        let [ur, uc] = u.split(',').map(Number);
        let currentPath = [[ur, uc]];

        while (unvisited.has(`${currentPath[currentPath.length - 1][0]},${currentPath[currentPath.length - 1][1]}`)) {
          let [lr, lc] = currentPath[currentPath.length - 1];
          const nbrs = [];
          [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
            const nr = lr + dr, nc = lc + dc;
            if (m.inBounds(nr, nc)) nbrs.push([nr, nc]);
          });
          const next = nbrs[Math.floor(rng() * nbrs.length)];
          const idx = currentPath.findIndex(p => p[0] === next[0] && p[1] === next[1]);
          if (idx !== -1) currentPath = currentPath.slice(0, idx + 1);
          else currentPath.push(next);
        }

        for (let i = 0; i < currentPath.length - 1; i++) {
          m.removeWall(currentPath[i], currentPath[i + 1]);
          unvisited.delete(`${currentPath[i][0]},${currentPath[i][1]}`);
          await update();
        }
        unvisited.delete(`${currentPath[currentPath.length - 1][0]},${currentPath[currentPath.length - 1][1]}`);
      }
    }

    async function genKruskal(m, update, signal) {
      const edges = [];
      for (const [r, c] of m.cells) {
        if (m.inBounds(r + 1, c)) edges.push([[r, c], [r + 1, c]]);
        if (m.inBounds(r, c + 1)) edges.push([[r, c], [r, c + 1]]);
      }
      for (let i = edges.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [edges[i], edges[j]] = [edges[j], edges[i]];
      }
      const parent = new Map();
      const find = (k) => {
        if (!parent.has(k)) parent.set(k, k);
        if (parent.get(k) !== k) parent.set(k, find(parent.get(k)));
        return parent.get(k);
      };
      const union = (k1, k2) => {
        const r1 = find(k1), r2 = find(k2);
        if (r1 !== r2) { parent.set(r2, r1); return true; }
        return false;
      };

      for (const [u, v] of edges) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        if (union(`${u[0]},${u[1]}`, `${v[0]},${v[1]}`)) {
          m.removeWall(u, v);
          await update();
        }
      }
    }

    async function genGrowing(m, update, signal) {
      let start = null;
      for (const c of m.cells) { start = c; break; }
      if (!start) return;
      const visited = new Set([`${start[0]},${start[1]}`]);
      const active = [start];
      const [sr, sc] = m.toGrid(start[0], start[1]);
      m.set(sr, sc, 0);

      while (active.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        const idx = (rng() > 0.5) ? active.length - 1 : Math.floor(rng() * active.length);
        const [r, c] = active[idx];
        const nbrs = [];
        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
          const nr = r + dr, nc = c + dc;
          if (m.inBounds(nr, nc) && !visited.has(`${nr},${nc}`)) nbrs.push([nr, nc]);
        });
        if (nbrs.length > 0) {
          const [nr, nc] = nbrs[Math.floor(rng() * nbrs.length)];
          m.removeWall([r, c], [nr, nc]);
          visited.add(`${nr},${nc}`);
          active.push([nr, nc]);
          await update();
        } else {
          active.splice(idx, 1);
        }
      }
    }

    async function genCaves(m, update, signal) {
      for (let r = 1; r < m.gh - 1; r++) {
        for (let c = 1; c < m.gw - 1; c++) {
          if (m.isValid(Math.floor((r - 1) / 2), Math.floor((c - 1) / 2))) { // Rough check
            m.set(r, c, (rng() < 0.45) ? 1 : 0);
          }
        }
      }
      await update();
      for (let i = 0; i < 5; i++) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        const nextGrid = new Int8Array(m.data);
        for (let r = 1; r < m.gh - 1; r++) {
          for (let c = 1; c < m.gw - 1; c++) {
            if (m.data[r * m.gw + c] === -1) continue;
            let walls = 0;
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                if (m.get(r + dr, c + dc) === 1) walls++;
              }
            }
            if (walls > 4) nextGrid[r * m.gw + c] = 1;
            else if (walls < 4) nextGrid[r * m.gw + c] = 0;
          }
        }
        m.data = nextGrid;
        await update();
      }
    }

    // Solvers
    async function solveMaze(signal) {
      if (!maze) return;
      pathMeshGroup.clear();
      // Reset floor colors
      if (floorInstancedMesh) {
        const c = new THREE.Color(0x001100);
        for (let i = 0; i < floorInstancedMesh.count; i++) floorInstancedMesh.setColorAt(i, c);
        floorInstancedMesh.instanceColor.needsUpdate = true;
      }

      const algo = ui.solveSelect.value;
      let start = null, goal = null;
      // Find valid start/goal
      for (let r = 1; r < maze.gh; r++) for (let c = 1; c < maze.gw; c++) if (maze.get(r, c) === 0) { start = [r, c]; break; }
      for (let r = maze.gh - 2; r > 0; r--) for (let c = maze.gw - 2; c > 0; c--) if (maze.get(r, c) === 0) { goal = [r, c]; break; }

      if (!start || !goal) return;

      let path = [];
      if (algo === 'bfs') path = await bfs(maze, start, goal, signal);
      else if (algo === 'astar') path = await astar(maze, start, goal, signal);
      else if (algo === 'bibfs') path = await bibfs(maze, start, goal, signal);
      else if (algo === 'dijkstra') path = await bfs(maze, start, goal, signal);

      if (path) drawPath3D(path);
      ui.pathLen.innerText = path ? path.length : "NO_DATA";
    }

    // Visualization Helper: Color floor instead of spawning cubes
    function highlightCell(r, c, colorHex) {
      if (!maze.floorMap) return;
      const idx = maze.floorMap.get(`${r},${c}`);
      if (idx !== undefined) {
        floorInstancedMesh.setColorAt(idx, new THREE.Color(colorHex));
        floorInstancedMesh.instanceColor.needsUpdate = true;
      }
    }

    async function bfs(m, start, goal, signal) {
      const q = [start];
      const parent = new Map();
      parent.set(start.toString(), null);
      const visited = new Set([start.toString()]);
      const speed = parseInt(ui.speed.value);
      let count = 0;

      while (q.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        const curr = q.shift();
        if (curr[0] === goal[0] && curr[1] === goal[1]) return reconstruct(parent, curr);

        const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dr, dc] of nbrs) {
          const nr = curr[0] + dr, nc = curr[1] + dc;
          const key = `${nr},${nc}`;
          if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !visited.has(key)) {
            visited.add(key);
            parent.set(key, curr);
            q.push([nr, nc]);
            if (count++ % speed === 0) { highlightCell(nr, nc, 0x008800); await sleep(5); }
          }
        }
      }
      return null;
    }

    async function astar(m, start, goal, signal) {
      const open = [{ pos: start, f: 0, g: 0 }];
      const parent = new Map();
      const visited = new Set();
      const h = (a, b) => Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
      const speed = parseInt(ui.speed.value);
      let count = 0;

      while (open.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        open.sort((a, b) => a.f - b.f);
        const { pos: curr, g } = open.shift();
        const key = curr.toString();
        if (visited.has(key)) continue;
        visited.add(key);
        if (curr[0] === goal[0] && curr[1] === goal[1]) return reconstruct(parent, curr);

        const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dr, dc] of nbrs) {
          const nr = curr[0] + dr, nc = curr[1] + dc;
          const nKey = `${nr},${nc}`;
          if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !visited.has(nKey)) {
            parent.set(nKey, curr);
            open.push({ pos: [nr, nc], g: g + 1, f: g + 1 + h([nr, nc], goal) });
            if (count++ % speed === 0) { highlightCell(nr, nc, 0x008800); await sleep(5); }
          }
        }
      }
      return null;
    }

    async function bibfs(m, start, goal, signal) {
      const q1 = [start], q2 = [goal];
      const p1 = new Map([[start.toString(), null]]);
      const p2 = new Map([[goal.toString(), null]]);
      const v1 = new Set([start.toString()]);
      const v2 = new Set([goal.toString()]);
      const speed = parseInt(ui.speed.value);
      let count = 0;

      while (q1.length > 0 && q2.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        if (q1.length > 0) {
          const c1 = q1.shift();
          const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          for (const [dr, dc] of nbrs) {
            const nr = c1[0] + dr, nc = c1[1] + dc;
            const key = `${nr},${nc}`;
            if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !v1.has(key)) {
              v1.add(key);
              p1.set(key, c1);
              q1.push([nr, nc]);
              if (v2.has(key)) return mergePaths(p1, p2, [nr, nc]);
              if (count++ % speed === 0) { highlightCell(nr, nc, 0x008800); await sleep(5); }
            }
          }
        }
        if (q2.length > 0) {
          const c2 = q2.shift();
          const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          for (const [dr, dc] of nbrs) {
            const nr = c2[0] + dr, nc = c2[1] + dc;
            const key = `${nr},${nc}`;
            if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !v2.has(key)) {
              v2.add(key);
              p2.set(key, c2);
              q2.push([nr, nc]);
              if (v1.has(key)) return mergePaths(p1, p2, [nr, nc]);
              if (count++ % speed === 0) { highlightCell(nr, nc, 0x008800); await sleep(5); }
            }
          }
        }
      }
      return null;
    }

    function reconstruct(parent, end) {
      const path = [end];
      let curr = end;
      while (parent.get(curr.toString())) {
        curr = parent.get(curr.toString());
        path.push(curr);
      }
      return path.reverse();
    }

    function mergePaths(p1, p2, meet) {
      const path1 = reconstruct(p1, meet);
      const path2 = reconstruct(p2, meet);
      return path1.slice(0, -1).concat(path2.reverse());
    }

    // --- HEATMAP ---
    async function showHeatmap() {
      if (!maze || !floorInstancedMesh) return;
      let start = null;
      for (let r = 1; r < maze.gh; r++) for (let c = 1; c < maze.gw; c++) if (maze.get(r, c) === 0) { start = [r, c]; break; }
      if (!start) return;

      const dists = new Int32Array(maze.gw * maze.gh).fill(-1);
      const q = [start];
      dists[start[0] * maze.gw + start[1]] = 0;
      let maxDist = 0;

      while (q.length > 0) {
        const [r, c] = q.shift();
        const d = dists[r * maze.gw + c];
        if (d > maxDist) maxDist = d;
        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < maze.gh && nc >= 0 && nc < maze.gw && maze.get(nr, nc) === 0 && dists[nr * maze.gw + nc] === -1) {
            dists[nr * maze.gw + nc] = d + 1;
            q.push([nr, nc]);
          }
        });
      }

      const color = new THREE.Color();
      for (let r = 0; r < maze.gh; r++) {
        for (let c = 0; c < maze.gw; c++) {
          if (maze.get(r, c) === 0) {
            const d = dists[r * maze.gw + c];
            const idx = maze.floorMap.get(`${r},${c}`);
            if (idx !== undefined) {
              if (d !== -1) {
                const t = d / maxDist;
                color.setHSL(0.33 - t * 0.33, 1, 0.5); // Green to Red
              } else {
                color.setHex(0x001100);
              }
              floorInstancedMesh.setColorAt(idx, color);
            }
          }
        }
      }
      floorInstancedMesh.instanceColor.needsUpdate = true;
    }

    function drawPath3D(path) {
      const points = [];
      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;

      path.forEach(([r, c]) => {
        points.push(new THREE.Vector3(c * CELL_SIZE + offsetX, 0.5, r * CELL_SIZE + offsetZ));
      });

      const curve = new THREE.CatmullRomCurve3(points);
      const geo = new THREE.TubeGeometry(curve, path.length * 4, 0.15, 8, false);
      const mat = new THREE.MeshBasicMaterial({ color: 0x00ff41 }); // Neon Green Glow
      const mesh = new THREE.Mesh(geo, mat);
      pathMeshGroup.add(mesh);
    }

    function calcStats(m) {
      let deadEnds = 0;
      let passages = 0;
      for (let r = 1; r < m.gh - 1; r++) {
        for (let c = 1; c < m.gw - 1; c++) {
          if (m.get(r, c) === 0) {
            passages++;
            let exits = 0;
            if (m.get(r + 1, c) === 0) exits++;
            if (m.get(r - 1, c) === 0) exits++;
            if (m.get(r, c + 1) === 0) exits++;
            if (m.get(r, c - 1) === 0) exits++;
            if (exits === 1) deadEnds++;
          }
        }
      }
      ui.cells.innerText = passages;
      ui.deadEnds.innerText = passages ? Math.round((deadEnds / passages) * 100) + '%' : '0%';
    }

    // --- GAME LOGIC ---
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const moveState = { fwd: false, bwd: false, left: false, right: false, run: false };

    document.addEventListener('keydown', (e) => {
      switch (e.code) {
        case 'KeyW': moveState.fwd = true; break;
        case 'KeyS': moveState.bwd = true; break;
        case 'KeyA': moveState.left = true; break;
        case 'KeyD': moveState.right = true; break;
        case 'ShiftLeft': moveState.run = true; break;
      }
    });
    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'KeyW': moveState.fwd = false; break;
        case 'KeyS': moveState.bwd = false; break;
        case 'KeyA': moveState.left = false; break;
        case 'KeyD': moveState.right = false; break;
        case 'ShiftLeft': moveState.run = false; break;
      }
    });

    function updateGameLogic() {
      if (!isGameMode) return;
      const delta = 0.015;
      const speed = moveState.run ? 15.0 : 8.0;
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      direction.z = Number(moveState.fwd) - Number(moveState.bwd);
      direction.x = Number(moveState.right) - Number(moveState.left);
      direction.normalize();
      if (moveState.fwd || moveState.bwd) velocity.z -= direction.z * speed * 10.0 * delta;
      if (moveState.left || moveState.right) velocity.x -= direction.x * speed * 10.0 * delta;
      fpsControls.moveRight(-velocity.x * delta);
      fpsControls.moveForward(-velocity.z * delta);

      const pos = camera.position;
      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;
      const gx = Math.round((pos.x - offsetX) / CELL_SIZE);
      const gz = Math.round((pos.z - offsetZ) / CELL_SIZE);

      if (gx < 0 || gx >= maze.gw || gz < 0 || gz >= maze.gh || maze.get(gz, gx) !== 0) {
        camera.position.x -= -velocity.x * delta;
        camera.position.z -= -velocity.z * delta;
        velocity.set(0, 0, 0);
      }

      // Goal check (simplified)
      // ...
    }

    window.exitGameMode = () => {
      ui.gameOverlay.style.display = 'none';
      isGameMode = false;
      controls.target.set(0, 0, 0);
      camera.position.set(0, 40, 40);
      controls.update();
    };

    // --- EVENTS ---
    document.getElementById('genBtn').onclick = () => runTask(generateMaze);
    document.getElementById('stopBtn').onclick = () => { if (abortController) abortController.abort(); };
    document.getElementById('solveBtn').onclick = () => runTask(solveMaze);
    document.getElementById('heatmapBtn').onclick = () => showHeatmap();
    document.getElementById('clearBtn').onclick = () => {
      pathMeshGroup.clear();
      if (floorInstancedMesh) {
        const c = new THREE.Color(0x001100);
        for (let i = 0; i < floorInstancedMesh.count; i++) floorInstancedMesh.setColorAt(i, c);
        floorInstancedMesh.instanceColor.needsUpdate = true;
      }
    };

    document.getElementById('viewOrbit').onclick = () => {
      isGameMode = false;
      document.exitPointerLock();
      controls.enabled = true;
    };
    document.getElementById('viewFPS').onclick = () => {
      if (!maze) return;
      isGameMode = true;
      controls.enabled = false;
      let start = null;
      for (let r = 1; r < maze.gh; r++) for (let c = 1; c < maze.gw; c++) if (maze.get(r, c) === 0) { start = [r, c]; break; }
      if (start) {
        const offsetX = -(maze.gw * CELL_SIZE) / 2;
        const offsetZ = -(maze.gh * CELL_SIZE) / 2;
        camera.position.set(start[1] * CELL_SIZE + offsetX, 1.2, start[0] * CELL_SIZE + offsetZ);
        fpsControls.lock();
      }
    };

    document.getElementById('togglePanelBtn').onclick = () => {
      document.getElementById('mainPanel').classList.toggle('collapsed');
    };

    // Init
    init3D();
    runTask(generateMaze);

  </script>
</body>

</html>