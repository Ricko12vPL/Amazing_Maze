<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Amazing Maze — Ultra Premium</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap"
    rel="stylesheet">
  <!-- Three.js CDN -->
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
    }
  }
</script>
  <style>
    :root {
      --bg-dark: #030305;
      --bg-panel: rgba(10, 10, 15, 0.85);
      --glass-border: rgba(255, 255, 255, 0.1);
      --text-main: #ffffff;
      --text-muted: #94a3b8;
      --accent-primary: #8b5cf6;
      /* Violet */
      --accent-glow: rgba(139, 92, 246, 0.5);
      --accent-secondary: #06b6d4;
      /* Cyan */
      --danger: #f43f5e;
      --success: #10b981;
      --radius-lg: 16px;
      --radius-md: 8px;
      --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 1);
      --font-sans: 'Outfit', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    * {
      box-sizing: border-box;
      outline: none;
      user-select: none;
    }

    body {
      margin: 0;
      height: 100vh;
      background-color: var(--bg-dark);
      color: var(--text-main);
      font-family: var(--font-sans);
      overflow: hidden;
    }

    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* 3D Canvas Layer */
    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
    }

    /* UI Layer */
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      /* Let clicks pass through to canvas where needed */
      display: flex;
      padding: 20px;
      gap: 20px;
    }

    /* Sidebar Panel */
    .panel {
      pointer-events: auto;
      width: 340px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 24px;
      background: var(--bg-panel);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      overflow-y: auto;
      max-height: 100%;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .panel.collapsed {
      transform: translateX(-360px);
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--glass-border);
      padding-bottom: 16px;
      margin-bottom: 4px;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #c4b5fd 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: -0.5px;
    }

    .badge {
      font-size: 10px;
      background: var(--accent-primary);
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }

    /* Controls */
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    label {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: var(--text-muted);
    }

    input[type=number],
    select {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      padding: 10px;
      color: white;
      font-family: var(--font-mono);
      font-size: 13px;
      width: 100%;
      transition: all 0.2s;
    }

    input[type=number]:focus,
    select:focus {
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px var(--accent-glow);
    }

    /* Buttons */
    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button {
      padding: 12px;
      border: none;
      border-radius: var(--radius-md);
      font-family: var(--font-sans);
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-primary), #7c3aed);
      color: white;
      box-shadow: 0 4px 12px var(--accent-glow);
    }

    .btn-primary:hover {
      filter: brightness(1.1);
      transform: translateY(-1px);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-main);
      border: 1px solid var(--glass-border);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .btn-success {
      background: linear-gradient(135deg, var(--accent-secondary), #0891b2);
      color: white;
      box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
    }

    .btn-danger {
      background: linear-gradient(135deg, var(--danger), #e11d48);
      color: white;
    }

    /* Stats Panel */
    .stats-panel {
      pointer-events: auto;
      position: absolute;
      top: 20px;
      right: 20px;
      width: 260px;
      background: var(--bg-panel);
      backdrop-filter: blur(24px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      padding-bottom: 8px;
    }

    .stat-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .stat-label {
      color: var(--text-muted);
    }

    .stat-val {
      font-family: var(--font-mono);
      font-weight: 700;
      color: var(--accent-secondary);
    }

    /* Game Overlay */
    #game-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: none;
      pointer-events: auto;
    }

    .game-msg {
      font-size: 48px;
      font-weight: 800;
      text-transform: uppercase;
      background: linear-gradient(to right, #fff, #cbd5e1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      margin-bottom: 20px;
    }

    /* Toggle Button */
    .toggle-panel-btn {
      pointer-events: auto;
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-panel);
      border: 1px solid var(--glass-border);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 20;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.2);
    }
  </style>
</head>

<body>

  <div id="app">
    <div id="canvas-container"></div>

    <div id="ui-layer">
      <aside class="panel" id="mainPanel">
        <div class="panel-header">
          <div>
            <h1>Amazing Maze</h1>
            <div style="font-size:12px; color:var(--text-muted)">Ultra Edition v3.0</div>
          </div>
          <span class="badge">3D</span>
        </div>

        <div class="control-group">
          <label>View Mode</label>
          <div class="btn-grid">
            <button id="viewOrbit" class="btn-secondary" style="background:var(--accent-glow)">Orbit</button>
            <button id="viewFPS" class="btn-secondary">Play (FPS)</button>
          </div>
        </div>

        <div class="control-group">
          <label>Dimensions</label>
          <div style="display:flex; gap:10px">
            <input id="widthInput" type="number" value="30" min="5" max="200" placeholder="W">
            <input id="heightInput" type="number" value="30" min="5" max="200" placeholder="H">
          </div>
        </div>

        <div class="control-group">
          <label>Generator</label>
          <select id="genSelect">
            <option value="dfs">Recursive Backtracker (DFS)</option>
            <option value="kruskal">Kruskal's Algorithm</option>
            <option value="prim">Prim's Algorithm (MST)</option>
            <option value="wilson">Wilson's (Loop-Erased)</option>
            <option value="growing">Growing Tree (Mix)</option>
          </select>
        </div>

        <div class="control-group">
          <label>Speed</label>
          <input id="speedInput" type="number" value="5" min="1" max="50">
        </div>

        <div class="btn-grid">
          <button id="genBtn" class="btn-primary">Generate</button>
          <button id="stopBtn" class="btn-danger">Stop</button>
        </div>

        <hr style="border:0; border-top:1px solid var(--glass-border); width:100%; margin:5px 0;">

        <div class="control-group">
          <label>Solver</label>
          <select id="solveSelect">
            <option value="bfs">BFS (Shortest Path)</option>
            <option value="bibfs">Bidirectional BFS</option>
            <option value="astar">A* Search</option>
            <option value="dijkstra">Dijkstra</option>
          </select>
        </div>

        <div class="btn-grid">
          <button id="solveBtn" class="btn-success">Solve</button>
          <button id="clearBtn" class="btn-secondary">Clear Path</button>
        </div>

        <div style="margin-top:auto; font-size:11px; color:var(--text-muted); line-height:1.5">
          <strong>Controls:</strong><br>
          Orbit: Left Click Rotate, Right Click Pan<br>
          FPS: WASD to Move, Shift to Run
        </div>
      </aside>

      <div class="stats-panel">
        <div class="stat-row">
          <span class="stat-label">Status</span>
          <span class="stat-val" id="statusVal">Idle</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Cells</span>
          <span class="stat-val" id="cellsVal">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Dead Ends</span>
          <span class="stat-val" id="deadEndsVal">0%</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Path Length</span>
          <span class="stat-val" id="pathLenVal">-</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Visited</span>
          <span class="stat-val" id="visitedVal">0</span>
        </div>
      </div>

      <div id="game-overlay">
        <div class="game-msg" id="gameMsg">VICTORY!</div>
        <button class="btn-primary" onclick="exitGameMode()">Exit Game Mode</button>
      </div>

      <button class="toggle-panel-btn" id="togglePanelBtn">≡</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // --- CONFIG ---
    const WALL_HEIGHT = 1.5;
    const CELL_SIZE = 1;
    const WALL_THICKNESS = 0.1; // Visual thickness

    // --- STATE ---
    let maze = null;
    let scene, camera, renderer, controls, fpsControls;
    let gridMesh, wallInstancedMesh, floorMesh;
    let pathMeshGroup = new THREE.Group();
    let highlightMeshGroup = new THREE.Group();
    let playerObj;
    let isGameMode = false;
    let animationId;
    let abortController = null;
    let isGenerating = false;

    // --- DOM ---
    const ui = {
      width: document.getElementById('widthInput'),
      height: document.getElementById('heightInput'),
      genSelect: document.getElementById('genSelect'),
      solveSelect: document.getElementById('solveSelect'),
      speed: document.getElementById('speedInput'),
      status: document.getElementById('statusVal'),
      cells: document.getElementById('cellsVal'),
      deadEnds: document.getElementById('deadEndsVal'),
      pathLen: document.getElementById('pathLenVal'),
      visited: document.getElementById('visitedVal'),
      gameOverlay: document.getElementById('game-overlay'),
      gameMsg: document.getElementById('gameMsg')
    };

    // --- MAZE DATA STRUCTURE ---
    class Maze {
      constructor(w, h) {
        this.w = w; this.h = h;
        this.grid = new Int8Array(w * h).fill(1); // 1 = Wall, 0 = Passage
        // We use a "Cell" based approach where grid[y*w+x] represents a cell.
        // Walls are implicit between cells.
        // Actually, for 3D visualization, it's easier to use the "Grid" approach from before:
        // 2*w+1 by 2*h+1.
        this.gw = 2 * w + 1;
        this.gh = 2 * h + 1;
        this.data = new Int8Array(this.gw * this.gh).fill(1);

        // Initialize cells as unvisited (walls everywhere)
        // We will carve out 0s.
        this.cells = [];
        for (let r = 0; r < h; r++) {
          for (let c = 0; c < w; c++) {
            this.cells.push([r, c]);
          }
        }
      }

      get(r, c) { return this.data[r * this.gw + c]; }
      set(r, c, v) { this.data[r * this.gw + c] = v; }

      // Convert abstract cell coord (0..w-1) to grid coord (1..gw-2)
      toGrid(r, c) { return [r * 2 + 1, c * 2 + 1]; }

      removeWall(c1, c2) {
        const [r1, c1x] = c1;
        const [r2, c2x] = c2;
        const [gr1, gc1] = this.toGrid(r1, c1x);
        const [gr2, gc2] = this.toGrid(r2, c2x);

        this.set(gr1, gc1, 0); // Cell 1
        this.set(gr2, gc2, 0); // Cell 2
        this.set((gr1 + gr2) >> 1, (gc1 + gc2) >> 1, 0); // Wall between
      }

      inBounds(r, c) { return r >= 0 && r < this.h && c >= 0 && c < this.w; }
    }

    // --- 3D ENGINE ---
    function init3D() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x030305, 0.02);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 40, 40);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.1);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.set(50, 100, 50);
      dirLight.castShadow = true;
      scene.add(dirLight);

      const pointLight = new THREE.PointLight(0x8b5cf6, 1, 50);
      pointLight.position.set(0, 10, 0);
      scene.add(pointLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      fpsControls = new PointerLockControls(camera, document.body);
      fpsControls.addEventListener('lock', () => { isGameMode = true; });
      fpsControls.addEventListener('unlock', () => {
        if (isGameMode) {
          // Just paused
        }
      });

      // Groups
      scene.add(pathMeshGroup);
      scene.add(highlightMeshGroup);

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function animate() {
      requestAnimationFrame(animate);

      if (isGameMode) {
        updateGameLogic();
      } else {
        controls.update();
      }

      renderer.render(scene, camera);
    }

    // --- RENDERING MAZE ---
    function renderMazeFull(m) {
      if (wallInstancedMesh) scene.remove(wallInstancedMesh);
      if (floorMesh) scene.remove(floorMesh);

      const geometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
      const material = new THREE.MeshStandardMaterial({
        color: 0x1e293b,
        roughness: 0.2,
        metalness: 0.5
      });

      // Count walls
      let wallCount = 0;
      for (let i = 0; i < m.data.length; i++) if (m.data[i] === 1) wallCount++;

      wallInstancedMesh = new THREE.InstancedMesh(geometry, material, wallCount);
      wallInstancedMesh.castShadow = true;
      wallInstancedMesh.receiveShadow = true;

      const dummy = new THREE.Object3D();
      let idx = 0;

      // Center the maze
      const offsetX = -(m.gw * CELL_SIZE) / 2;
      const offsetZ = -(m.gh * CELL_SIZE) / 2;

      for (let r = 0; r < m.gh; r++) {
        for (let c = 0; c < m.gw; c++) {
          if (m.data[r * m.gw + c] === 1) {
            dummy.position.set(c * CELL_SIZE + offsetX, WALL_HEIGHT / 2, r * CELL_SIZE + offsetZ);
            dummy.updateMatrix();
            wallInstancedMesh.setMatrixAt(idx++, dummy.matrix);
          }
        }
      }

      scene.add(wallInstancedMesh);

      // Floor
      const floorGeo = new THREE.PlaneGeometry(m.gw * CELL_SIZE, m.gh * CELL_SIZE);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x0f172a, roughness: 0.8 });
      floorMesh = new THREE.Mesh(floorGeo, floorMat);
      floorMesh.rotation.x = -Math.PI / 2;
      floorMesh.position.y = 0;
      floorMesh.receiveShadow = true;
      scene.add(floorMesh);

      // Adjust Camera
      if (!isGameMode) {
        controls.target.set(0, 0, 0);
        camera.position.set(0, Math.max(m.gw, m.gh) * 1.2, Math.max(m.gw, m.gh) * 0.8);
        controls.update();
      }
    }

    function updateCellVisual(r, c, type) {
      // For real-time updates, we might need a different approach than InstancedMesh for walls if walls are changing.
      // Since walls are REMOVED, we can just scale them to 0 in the instanced mesh?
      // Or simpler: Just re-render the whole mesh every N frames or use a dynamic group for "walls being removed".
      // For this demo, we will re-render full maze periodically or use a separate system for "active generation".
      // Actually, let's just use simple meshes for the "active" part and bake later? 
      // Optimization: We will just re-generate the InstancedMesh every batch.
    }

    // --- ALGORITHMS ---

    async function runTask(fn) {
      if (abortController) abortController.abort();
      abortController = new AbortController();
      isGenerating = true;
      ui.status.innerText = "Running...";
      try {
        await fn(abortController.signal);
        ui.status.innerText = "Done";
      } catch (e) {
        if (e.name === 'AbortError') ui.status.innerText = "Stopped";
        else console.error(e);
      }
      isGenerating = false;
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function rng() { return Math.random(); }

    // Generators
    async function generateMaze(signal) {
      const w = parseInt(ui.width.value);
      const h = parseInt(ui.height.value);
      maze = new Maze(w, h);

      // Initial render (full walls)
      renderMazeFull(maze);

      const algo = ui.genSelect.value;
      const speed = parseInt(ui.speed.value);
      const delay = Math.max(1, 50 - speed);

      // Helper to visualize
      let batch = 0;
      const updateVis = async () => {
        if (batch++ % speed === 0) {
          renderMazeFull(maze);
          await sleep(10);
        }
      };

      if (algo === 'dfs') await genDFS(maze, updateVis, signal);
      else if (algo === 'kruskal') await genKruskal(maze, updateVis, signal);
      else if (algo === 'prim') await genPrim(maze, updateVis, signal);
      else if (algo === 'wilson') await genWilson(maze, updateVis, signal);
      else if (algo === 'growing') await genGrowing(maze, updateVis, signal);

      renderMazeFull(maze);
      calcStats(maze);
    }

    async function genDFS(m, update, signal) {
      const stack = [[0, 0]];
      const visited = new Set(['0,0']);
      m.set(1, 1, 0); // Clear start

      while (stack.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        const [r, c] = stack[stack.length - 1];
        const nbrs = [];
        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
          const nr = r + dr, nc = c + dc;
          if (m.inBounds(nr, nc) && !visited.has(`${nr},${nc}`)) nbrs.push([nr, nc]);
        });

        if (nbrs.length > 0) {
          const [nr, nc] = nbrs[Math.floor(rng() * nbrs.length)];
          m.removeWall([r, c], [nr, nc]);
          visited.add(`${nr},${nc}`);
          stack.push([nr, nc]);
          await update();
        } else {
          stack.pop();
        }
      }
    }

    async function genPrim(m, update, signal) {
      // Randomized Prim's
      const walls = [];
      const visited = new Set(['0,0']);
      m.set(1, 1, 0);

      // Add walls of (0,0)
      [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
        const nr = 0 + dr, nc = 0 + dc;
        if (m.inBounds(nr, nc)) walls.push([[0, 0], [nr, nc]]);
      });

      while (walls.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        const idx = Math.floor(rng() * walls.length);
        const [p, n] = walls[idx];
        walls.splice(idx, 1);

        const nKey = `${n[0]},${n[1]}`;
        if (!visited.has(nKey)) {
          m.removeWall(p, n);
          visited.add(nKey);

          [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
            const nr = n[0] + dr, nc = n[1] + dc;
            if (m.inBounds(nr, nc) && !visited.has(`${nr},${nc}`)) {
              walls.push([n, [nr, nc]]);
            }
          });
          await update();
        }
      }
    }

    async function genWilson(m, update, signal) {
      const w = m.w, h = m.h;
      const unvisited = new Set();
      for (let r = 0; r < h; r++) for (let c = 0; c < w; c++) unvisited.add(`${r},${c}`);

      // Pick random start, mark visited
      const first = [...unvisited][Math.floor(rng() * unvisited.size)];
      unvisited.delete(first);
      const [fr, fc] = first.split(',').map(Number);
      m.set(fr * 2 + 1, fc * 2 + 1, 0);

      while (unvisited.size > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        let currKey = [...unvisited][Math.floor(rng() * unvisited.size)];
        let [cr, cc] = currKey.split(',').map(Number);
        let path = { [currKey]: null }; // Map for loop erasure

        // Random walk until we hit visited
        while (unvisited.has(currKey)) {
          const nbrs = [];
          [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
            const nr = cr + dr, nc = cc + dc;
            if (m.inBounds(nr, nc)) nbrs.push([nr, nc]);
          });
          const next = nbrs[Math.floor(rng() * nbrs.length)];
          const nextKey = `${next[0]},${next[1]}`;
          path[currKey] = next;
          currKey = nextKey;
          [cr, cc] = next;
        }

        // Carve path
        let walkKey = Object.keys(path)[0]; // Start of this walk
        // Wait, we need to start from the random start of the walk
        // Actually, we need to reconstruct from the start of the walk
        // Let's restart the walk logic slightly to be cleaner
        // ... Simplified Wilson:
        let u = [...unvisited][Math.floor(rng() * unvisited.size)];
        let [ur, uc] = u.split(',').map(Number);
        let currentPath = [[ur, uc]];

        while (unvisited.has(`${currentPath[currentPath.length - 1][0]},${currentPath[currentPath.length - 1][1]}`)) {
          let [lr, lc] = currentPath[currentPath.length - 1];
          // Random move
          const nbrs = [];
          [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
            const nr = lr + dr, nc = lc + dc;
            if (m.inBounds(nr, nc)) nbrs.push([nr, nc]);
          });
          const next = nbrs[Math.floor(rng() * nbrs.length)];

          // Check loop
          const idx = currentPath.findIndex(p => p[0] === next[0] && p[1] === next[1]);
          if (idx !== -1) {
            currentPath = currentPath.slice(0, idx + 1); // Erase loop
          } else {
            currentPath.push(next);
          }
        }

        // Carve
        for (let i = 0; i < currentPath.length - 1; i++) {
          m.removeWall(currentPath[i], currentPath[i + 1]);
          unvisited.delete(`${currentPath[i][0]},${currentPath[i][1]}`);
          await update();
        }
        unvisited.delete(`${currentPath[currentPath.length - 1][0]},${currentPath[currentPath.length - 1][1]}`);
      }
    }

    async function genKruskal(m, update, signal) {
      const edges = [];
      for (let r = 0; r < m.h; r++) {
        for (let c = 0; c < m.w; c++) {
          if (r + 1 < m.h) edges.push([[r, c], [r + 1, c]]);
          if (c + 1 < m.w) edges.push([[r, c], [r, c + 1]]);
        }
      }
      // Shuffle
      for (let i = edges.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [edges[i], edges[j]] = [edges[j], edges[i]];
      }

      const parent = new Int32Array(m.w * m.h).fill(-1);
      const find = (i) => parent[i] < 0 ? i : (parent[i] = find(parent[i]));
      const union = (i, j) => {
        const rootI = find(i), rootJ = find(j);
        if (rootI !== rootJ) { parent[rootJ] = rootI; return true; }
        return false;
      };

      for (const [u, v] of edges) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        const uIdx = u[0] * m.w + u[1];
        const vIdx = v[0] * m.w + v[1];
        if (union(uIdx, vIdx)) {
          m.removeWall(u, v);
          await update();
        }
      }
    }

    async function genGrowing(m, update, signal) {
      // Growing Tree with 50/50 split (Prim/DFS mix)
      const visited = new Set(['0,0']);
      const active = [[0, 0]];
      m.set(1, 1, 0);

      while (active.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        const idx = (rng() > 0.5) ? active.length - 1 : Math.floor(rng() * active.length);
        const [r, c] = active[idx];

        const nbrs = [];
        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
          const nr = r + dr, nc = c + dc;
          if (m.inBounds(nr, nc) && !visited.has(`${nr},${nc}`)) nbrs.push([nr, nc]);
        });

        if (nbrs.length > 0) {
          const [nr, nc] = nbrs[Math.floor(rng() * nbrs.length)];
          m.removeWall([r, c], [nr, nc]);
          visited.add(`${nr},${nc}`);
          active.push([nr, nc]);
          await update();
        } else {
          active.splice(idx, 1);
        }
      }
    }

    // Solvers
    async function solveMaze(signal) {
      if (!maze) return;

      // Clear old path
      pathMeshGroup.clear();

      const algo = ui.solveSelect.value;
      const start = [1, 1]; // Grid coords
      const goal = [maze.gh - 2, maze.gw - 2];

      // Ensure start/goal are 0
      if (maze.get(start[0], start[1]) !== 0) { ui.status.innerText = "Invalid Start"; return; }

      let path = [];

      if (algo === 'bfs') path = await bfs(maze, start, goal, signal);
      else if (algo === 'astar') path = await astar(maze, start, goal, signal);
      else if (algo === 'bibfs') path = await bibfs(maze, start, goal, signal);
      else if (algo === 'dijkstra') path = await bfs(maze, start, goal, signal); // Dijkstra is BFS on unweighted

      if (path) drawPath3D(path);
      ui.pathLen.innerText = path ? path.length : "No Path";
    }

    async function bfs(m, start, goal, signal) {
      const q = [start];
      const parent = new Map();
      parent.set(start.toString(), null);
      const visited = new Set([start.toString()]);

      const speed = parseInt(ui.speed.value);
      let count = 0;

      while (q.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        const curr = q.shift();
        if (curr[0] === goal[0] && curr[1] === goal[1]) return reconstruct(parent, curr);

        const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dr, dc] of nbrs) {
          const nr = curr[0] + dr, nc = curr[1] + dc;
          const key = `${nr},${nc}`;
          if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !visited.has(key)) {
            visited.add(key);
            parent.set(key, curr);
            q.push([nr, nc]);

            // Visualize search
            if (count++ % speed === 0) {
              drawPoint(nr, nc, 0x06b6d4);
              await sleep(5);
            }
          }
        }
      }
      return null;
    }

    async function astar(m, start, goal, signal) {
      // Simple Priority Queue would be better, but array sort is okay for demo size
      const open = [{ pos: start, f: 0, g: 0 }];
      const parent = new Map();
      const visited = new Set();

      const h = (a, b) => Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
      const speed = parseInt(ui.speed.value);
      let count = 0;

      while (open.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        open.sort((a, b) => a.f - b.f);
        const { pos: curr, g } = open.shift();
        const key = curr.toString();

        if (visited.has(key)) continue;
        visited.add(key);

        if (curr[0] === goal[0] && curr[1] === goal[1]) return reconstruct(parent, curr);

        const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dr, dc] of nbrs) {
          const nr = curr[0] + dr, nc = curr[1] + dc;
          const nKey = `${nr},${nc}`;
          if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !visited.has(nKey)) {
            parent.set(nKey, curr);
            open.push({ pos: [nr, nc], g: g + 1, f: g + 1 + h([nr, nc], goal) });

            if (count++ % speed === 0) {
              drawPoint(nr, nc, 0x8b5cf6);
              await sleep(5);
            }
          }
        }
      }
      return null;
    }

    async function bibfs(m, start, goal, signal) {
      const q1 = [start], q2 = [goal];
      const p1 = new Map([[start.toString(), null]]);
      const p2 = new Map([[goal.toString(), null]]);
      const v1 = new Set([start.toString()]);
      const v2 = new Set([goal.toString()]);

      const speed = parseInt(ui.speed.value);
      let count = 0;

      while (q1.length > 0 && q2.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        // Step 1
        if (q1.length > 0) {
          const c1 = q1.shift();
          const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          for (const [dr, dc] of nbrs) {
            const nr = c1[0] + dr, nc = c1[1] + dc;
            const key = `${nr},${nc}`;
            if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !v1.has(key)) {
              v1.add(key);
              p1.set(key, c1);
              q1.push([nr, nc]);
              if (v2.has(key)) return mergePaths(p1, p2, [nr, nc]);
              if (count++ % speed === 0) { drawPoint(nr, nc, 0x06b6d4); await sleep(5); }
            }
          }
        }

        // Step 2
        if (q2.length > 0) {
          const c2 = q2.shift();
          const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          for (const [dr, dc] of nbrs) {
            const nr = c2[0] + dr, nc = c2[1] + dc;
            const key = `${nr},${nc}`;
            if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !v2.has(key)) {
              v2.add(key);
              p2.set(key, c2);
              q2.push([nr, nc]);
              if (v1.has(key)) return mergePaths(p1, p2, [nr, nc]);
              if (count++ % speed === 0) { drawPoint(nr, nc, 0xf43f5e); await sleep(5); }
            }
          }
        }
      }
      return null;
    }

    function reconstruct(parent, end) {
      const path = [end];
      let curr = end;
      while (parent.get(curr.toString())) {
        curr = parent.get(curr.toString());
        path.push(curr);
      }
      return path.reverse();
    }

    function mergePaths(p1, p2, meet) {
      const path1 = reconstruct(p1, meet);
      const path2 = reconstruct(p2, meet);
      return path1.slice(0, -1).concat(path2.reverse());
    }

    // --- VISUALIZATION HELPERS ---
    function drawPoint(r, c, color) {
      const geo = new THREE.BoxGeometry(CELL_SIZE * 0.8, 0.5, CELL_SIZE * 0.8);
      const mat = new THREE.MeshBasicMaterial({ color: color });
      const mesh = new THREE.Mesh(geo, mat);
      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;
      mesh.position.set(c * CELL_SIZE + offsetX, 0.5, r * CELL_SIZE + offsetZ);
      pathMeshGroup.add(mesh);
    }

    function drawPath3D(path) {
      const points = [];
      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;

      path.forEach(([r, c]) => {
        points.push(new THREE.Vector3(c * CELL_SIZE + offsetX, 1, r * CELL_SIZE + offsetZ));
      });

      const curve = new THREE.CatmullRomCurve3(points);
      const geo = new THREE.TubeGeometry(curve, path.length * 2, 0.2, 8, false);
      const mat = new THREE.MeshStandardMaterial({ color: 0x10b981, emissive: 0x10b981, emissiveIntensity: 0.5 });
      const mesh = new THREE.Mesh(geo, mat);
      pathMeshGroup.add(mesh);
    }

    function calcStats(m) {
      let deadEnds = 0;
      let passages = 0;
      for (let r = 1; r < m.gh - 1; r += 2) {
        for (let c = 1; c < m.gw - 1; c += 2) {
          if (m.get(r, c) === 0) {
            passages++;
            let exits = 0;
            if (m.get(r + 1, c) === 0) exits++;
            if (m.get(r - 1, c) === 0) exits++;
            if (m.get(r, c + 1) === 0) exits++;
            if (m.get(r, c - 1) === 0) exits++;
            if (exits === 1) deadEnds++;
          }
        }
      }
      ui.cells.innerText = passages;
      ui.deadEnds.innerText = Math.round((deadEnds / passages) * 100) + '%';
    }

    // --- GAME LOGIC ---
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const moveState = { fwd: false, bwd: false, left: false, right: false, run: false };

    document.addEventListener('keydown', (e) => {
      switch (e.code) {
        case 'KeyW': moveState.fwd = true; break;
        case 'KeyS': moveState.bwd = true; break;
        case 'KeyA': moveState.left = true; break;
        case 'KeyD': moveState.right = true; break;
        case 'ShiftLeft': moveState.run = true; break;
      }
    });
    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'KeyW': moveState.fwd = false; break;
        case 'KeyS': moveState.bwd = false; break;
        case 'KeyA': moveState.left = false; break;
        case 'KeyD': moveState.right = false; break;
        case 'ShiftLeft': moveState.run = false; break;
      }
    });

    function updateGameLogic() {
      if (!isGameMode) return;

      const delta = 0.015; // Fixed step for simplicity
      const speed = moveState.run ? 15.0 : 8.0;

      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;

      direction.z = Number(moveState.fwd) - Number(moveState.bwd);
      direction.x = Number(moveState.right) - Number(moveState.left);
      direction.normalize();

      if (moveState.fwd || moveState.bwd) velocity.z -= direction.z * speed * 10.0 * delta;
      if (moveState.left || moveState.right) velocity.x -= direction.x * speed * 10.0 * delta;

      fpsControls.moveRight(-velocity.x * delta);
      fpsControls.moveForward(-velocity.z * delta);

      // Collision Detection (Simple Grid Check)
      const pos = camera.position;
      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;

      // Convert world pos to grid pos
      const gx = Math.round((pos.x - offsetX) / CELL_SIZE);
      const gz = Math.round((pos.z - offsetZ) / CELL_SIZE);

      // Check bounds and walls
      if (gx < 0 || gx >= maze.gw || gz < 0 || gz >= maze.gh || maze.get(gz, gx) === 1) {
        // Push back (very simple)
        camera.position.x -= -velocity.x * delta;
        camera.position.z -= -velocity.z * delta;
        velocity.set(0, 0, 0);
      }

      // Check Goal
      const goalX = maze.gw - 2;
      const goalZ = maze.gh - 2;
      if (Math.abs(gx - goalX) < 2 && Math.abs(gz - goalZ) < 2) {
        ui.gameOverlay.style.display = 'block';
        document.exitPointerLock();
        isGameMode = false;
      }
    }

    window.exitGameMode = () => {
      ui.gameOverlay.style.display = 'none';
      isGameMode = false;
      // Reset camera
      controls.target.set(0, 0, 0);
      camera.position.set(0, 40, 40);
      controls.update();
    };

    // --- EVENTS ---
    document.getElementById('genBtn').onclick = () => runTask(generateMaze);
    document.getElementById('stopBtn').onclick = () => { if (abortController) abortController.abort(); };
    document.getElementById('solveBtn').onclick = () => runTask(solveMaze);
    document.getElementById('clearBtn').onclick = () => pathMeshGroup.clear();

    document.getElementById('viewOrbit').onclick = () => {
      isGameMode = false;
      document.exitPointerLock();
      controls.enabled = true;
    };
    document.getElementById('viewFPS').onclick = () => {
      if (!maze) return;
      isGameMode = true;
      controls.enabled = false;

      // Teleport to start
      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;
      camera.position.set(1 * CELL_SIZE + offsetX, 1.5, 1 * CELL_SIZE + offsetZ);

      fpsControls.lock();
    };

    document.getElementById('togglePanelBtn').onclick = () => {
      document.getElementById('mainPanel').classList.toggle('collapsed');
    };

    // Init
    init3D();
    runTask(generateMaze);

  </script>
</body>

</html>