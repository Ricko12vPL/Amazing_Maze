<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Amazing Maze — Ultra Premium</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;700&display=swap"
    rel="stylesheet">
  <!-- Three.js CDN -->
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
    }
  }
</script>
  <style>
    :root {
      --bg-dark: #030305;
      --bg-panel: rgba(10, 10, 15, 0.85);
      --glass-border: rgba(255, 255, 255, 0.1);
      --text-main: #ffffff;
      --text-muted: #94a3b8;
      --accent-primary: #8b5cf6;
      /* Violet */
      --accent-glow: rgba(139, 92, 246, 0.5);
      --accent-secondary: #06b6d4;
      /* Cyan */
      --danger: #f43f5e;
      --success: #10b981;
      --radius-lg: 16px;
      --radius-md: 8px;
      --shadow-lg: 0 25px 50px -12px rgba(0, 0, 0, 1);
      --font-sans: 'Outfit', sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    * {
      box-sizing: border-box;
      outline: none;
      user-select: none;
    }

    body {
      margin: 0;
      height: 100vh;
      background-color: var(--bg-dark);
      color: var(--text-main);
      font-family: var(--font-sans);
      overflow: hidden;
    }

    #app {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    /* 3D Canvas Layer */
    #canvas-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
    }

    /* UI Layer */
    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
      /* Let clicks pass through to canvas where needed */
      display: flex;
      padding: 20px;
      gap: 20px;
    }

    /* Sidebar Panel */
    .panel {
      pointer-events: auto;
      width: 340px;
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding: 24px;
      background: var(--bg-panel);
      backdrop-filter: blur(24px);
      -webkit-backdrop-filter: blur(24px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      box-shadow: var(--shadow-lg);
      overflow-y: auto;
      max-height: 100%;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .panel.collapsed {
      transform: translateX(-360px);
    }

    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--glass-border);
      padding-bottom: 16px;
      margin-bottom: 4px;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, #c4b5fd 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: -0.5px;
    }

    .badge {
      font-size: 10px;
      background: var(--accent-primary);
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 600;
      text-transform: uppercase;
    }

    /* Controls */
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    label {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.8px;
      color: var(--text-muted);
    }

    input[type=number],
    select {
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-md);
      padding: 10px;
      color: white;
      font-family: var(--font-mono);
      font-size: 13px;
      width: 100%;
      transition: all 0.2s;
    }

    input[type=number]:focus,
    select:focus {
      border-color: var(--accent-primary);
      box-shadow: 0 0 0 2px var(--accent-glow);
    }

    /* Buttons */
    .btn-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button {
      padding: 12px;
      border: none;
      border-radius: var(--radius-md);
      font-family: var(--font-sans);
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--accent-primary), #7c3aed);
      color: white;
      box-shadow: 0 4px 12px var(--accent-glow);
    }

    .btn-primary:hover {
      filter: brightness(1.1);
      transform: translateY(-1px);
    }

    .btn-primary:active {
      transform: translateY(0);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-main);
      border: 1px solid var(--glass-border);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .btn-success {
      background: linear-gradient(135deg, var(--accent-secondary), #0891b2);
      color: white;
      box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
    }

    .btn-danger {
      background: linear-gradient(135deg, var(--danger), #e11d48);
      color: white;
    }

    /* Stats Panel */
    .stats-panel {
      pointer-events: auto;
      position: absolute;
      top: 20px;
      right: 20px;
      width: 260px;
      background: var(--bg-panel);
      backdrop-filter: blur(24px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: 20px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      font-size: 13px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      padding-bottom: 8px;
    }

    .stat-row:last-child {
      border-bottom: none;
      padding-bottom: 0;
    }

    .stat-label {
      color: var(--text-muted);
    }

    .stat-val {
      font-family: var(--font-mono);
      font-weight: 700;
      color: var(--accent-secondary);
    }

    /* Game Overlay */
    #game-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      display: none;
      pointer-events: auto;
    }

    .game-msg {
      font-size: 48px;
      font-weight: 800;
      text-transform: uppercase;
      background: linear-gradient(to right, #fff, #cbd5e1);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      margin-bottom: 20px;
    }

    /* Toggle Button */
    .toggle-panel-btn {
      pointer-events: auto;
      position: absolute;
      bottom: 20px;
      left: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-panel);
      border: 1px solid var(--glass-border);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 20;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.2);
    }
  </style>
</head>

<body>

  <div id="app">
    <div id="canvas-container"></div>

    <div id="ui-layer">
      <aside class="panel" id="mainPanel">
        <div class="panel-header">
          <div>
            <h1>Amazing Maze</h1>
            <div style="font-size:12px; color:var(--text-muted)">Ultra Edition v3.1</div>
          </div>
          <span class="badge">3D</span>
        </div>

        <div class="control-group">
          <label>View Mode</label>
          <div class="btn-grid">
            <button id="viewOrbit" class="btn-secondary" style="background:var(--accent-glow)">Orbit</button>
            <button id="viewFPS" class="btn-secondary">Play (FPS)</button>
          </div>
        </div>

        <div class="control-group">
          <label>Dimensions</label>
          <div style="display:flex; gap:10px">
            <input id="widthInput" type="number" value="30" min="5" max="200" placeholder="W">
            <input id="heightInput" type="number" value="30" min="5" max="200" placeholder="H">
          </div>
        </div>

        <div class="control-group">
          <label>Generator</label>
          <select id="genSelect">
            <option value="dfs">Recursive Backtracker (DFS)</option>
            <option value="kruskal">Kruskal's Algorithm</option>
            <option value="prim">Prim's Algorithm (MST)</option>
            <option value="wilson">Wilson's (Loop-Erased)</option>
            <option value="growing">Growing Tree (Mix)</option>
            <option value="caves">Caves (Cellular Automata)</option>
          </select>
        </div>

        <div class="control-group">
          <label>Speed</label>
          <input id="speedInput" type="number" value="5" min="1" max="50">
        </div>

        <div class="btn-grid">
          <button id="genBtn" class="btn-primary">Generate</button>
          <button id="stopBtn" class="btn-danger">Stop</button>
        </div>

        <hr style="border:0; border-top:1px solid var(--glass-border); width:100%; margin:5px 0;">

        <div class="control-group">
          <label>Solver</label>
          <select id="solveSelect">
            <option value="bfs">BFS (Shortest Path)</option>
            <option value="bibfs">Bidirectional BFS</option>
            <option value="astar">A* Search</option>
            <option value="dijkstra">Dijkstra</option>
          </select>
        </div>

        <div class="btn-grid">
          <button id="solveBtn" class="btn-success">Solve</button>
          <button id="heatmapBtn" class="btn-secondary">Heatmap</button>
        </div>

        <div class="btn-grid">
          <button id="clearBtn" class="btn-secondary">Clear Path</button>
        </div>

        <div style="margin-top:auto; font-size:11px; color:var(--text-muted); line-height:1.5">
          <strong>Controls:</strong><br>
          Orbit: Left Click Rotate, Right Click Pan<br>
          FPS: WASD to Move, Shift to Run
        </div>
      </aside>

      <div class="stats-panel">
        <div class="stat-row">
          <span class="stat-label">Status</span>
          <span class="stat-val" id="statusVal">Idle</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Cells</span>
          <span class="stat-val" id="cellsVal">0</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Dead Ends</span>
          <span class="stat-val" id="deadEndsVal">0%</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Path Length</span>
          <span class="stat-val" id="pathLenVal">-</span>
        </div>
        <div class="stat-row">
          <span class="stat-label">Visited</span>
          <span class="stat-val" id="visitedVal">0</span>
        </div>
      </div>

      <div id="game-overlay">
        <div class="game-msg" id="gameMsg">VICTORY!</div>
        <button class="btn-primary" onclick="exitGameMode()">Exit Game Mode</button>
      </div>

      <button class="toggle-panel-btn" id="togglePanelBtn">≡</button>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

    // --- CONFIG ---
    const WALL_HEIGHT = 1.5;
    const CELL_SIZE = 1;
    const WALL_THICKNESS = 0.1; // Visual thickness

    // --- STATE ---
    let maze = null;
    let scene, camera, renderer, controls, fpsControls;
    let wallInstancedMesh, floorInstancedMesh;
    let pathMeshGroup = new THREE.Group();
    let highlightMeshGroup = new THREE.Group();
    let isGameMode = false;
    let abortController = null;
    let isGenerating = false;

    // --- DOM ---
    const ui = {
      width: document.getElementById('widthInput'),
      height: document.getElementById('heightInput'),
      genSelect: document.getElementById('genSelect'),
      solveSelect: document.getElementById('solveSelect'),
      speed: document.getElementById('speedInput'),
      status: document.getElementById('statusVal'),
      cells: document.getElementById('cellsVal'),
      deadEnds: document.getElementById('deadEndsVal'),
      pathLen: document.getElementById('pathLenVal'),
      visited: document.getElementById('visitedVal'),
      gameOverlay: document.getElementById('game-overlay'),
      gameMsg: document.getElementById('gameMsg')
    };

    // --- MAZE DATA STRUCTURE ---
    class Maze {
      constructor(w, h) {
        this.w = w; this.h = h;
        this.grid = new Int8Array(w * h).fill(1);
        this.gw = 2 * w + 1;
        this.gh = 2 * h + 1;
        this.data = new Int8Array(this.gw * this.gh).fill(1);

        this.cells = [];
        for (let r = 0; r < h; r++) {
          for (let c = 0; c < w; c++) {
            this.cells.push([r, c]);
          }
        }
      }

      get(r, c) { return this.data[r * this.gw + c]; }
      set(r, c, v) { this.data[r * this.gw + c] = v; }

      toGrid(r, c) { return [r * 2 + 1, c * 2 + 1]; }

      removeWall(c1, c2) {
        const [r1, c1x] = c1;
        const [r2, c2x] = c2;
        const [gr1, gc1] = this.toGrid(r1, c1x);
        const [gr2, gc2] = this.toGrid(r2, c2x);

        this.set(gr1, gc1, 0);
        this.set(gr2, gc2, 0);
        this.set((gr1 + gr2) >> 1, (gc1 + gc2) >> 1, 0);
      }

      inBounds(r, c) { return r >= 0 && r < this.h && c >= 0 && c < this.w; }
    }

    // --- 3D ENGINE ---
    function init3D() {
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x030305, 0.02);

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 40, 40);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.1);
      scene.add(ambient);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
      dirLight.position.set(50, 100, 50);
      dirLight.castShadow = true;
      scene.add(dirLight);

      const pointLight = new THREE.PointLight(0x8b5cf6, 1, 50);
      pointLight.position.set(0, 10, 0);
      scene.add(pointLight);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;

      fpsControls = new PointerLockControls(camera, document.body);
      fpsControls.addEventListener('lock', () => { isGameMode = true; updateFog(); });
      fpsControls.addEventListener('unlock', () => {
        if (isGameMode) {
          // Just paused
        }
      });

      // Groups
      scene.add(pathMeshGroup);
      scene.add(highlightMeshGroup);

      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    }

    function updateFog() {
      if (isGameMode) {
        scene.fog.density = 0.15; // Dense fog for game mode
      } else {
        scene.fog.density = 0.02; // Light fog for orbit
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      if (isGameMode) {
        updateGameLogic();
      } else {
        controls.update();
      }

      renderer.render(scene, camera);
    }

    // --- RENDERING MAZE ---
    function renderMazeFull(m) {
      if (wallInstancedMesh) scene.remove(wallInstancedMesh);
      if (floorInstancedMesh) scene.remove(floorInstancedMesh);

      // Wall Mesh
      const wallGeo = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
      const wallMat = new THREE.MeshStandardMaterial({
        color: 0x1e293b,
        roughness: 0.2,
        metalness: 0.5
      });

      // Floor Mesh (Instanced for Heatmap support)
      const floorGeo = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
      const floorMat = new THREE.MeshStandardMaterial({ color: 0x0f172a, roughness: 0.8 });

      // Count walls and floors
      let wallCount = 0;
      let floorCount = 0;
      for (let i = 0; i < m.data.length; i++) {
        if (m.data[i] === 1) wallCount++;
        else floorCount++;
      }

      wallInstancedMesh = new THREE.InstancedMesh(wallGeo, wallMat, wallCount);
      wallInstancedMesh.castShadow = true;
      wallInstancedMesh.receiveShadow = true;

      floorInstancedMesh = new THREE.InstancedMesh(floorGeo, floorMat, floorCount);
      floorInstancedMesh.receiveShadow = true;

      const dummy = new THREE.Object3D();
      let wIdx = 0, fIdx = 0;

      // Center the maze
      const offsetX = -(m.gw * CELL_SIZE) / 2;
      const offsetZ = -(m.gh * CELL_SIZE) / 2;

      for (let r = 0; r < m.gh; r++) {
        for (let c = 0; c < m.gw; c++) {
          const val = m.data[r * m.gw + c];
          if (val === 1) {
            dummy.position.set(c * CELL_SIZE + offsetX, WALL_HEIGHT / 2, r * CELL_SIZE + offsetZ);
            dummy.rotation.set(0, 0, 0);
            dummy.updateMatrix();
            wallInstancedMesh.setMatrixAt(wIdx++, dummy.matrix);
          } else {
            dummy.position.set(c * CELL_SIZE + offsetX, 0, r * CELL_SIZE + offsetZ);
            dummy.rotation.set(-Math.PI / 2, 0, 0);
            dummy.updateMatrix();
            floorInstancedMesh.setMatrixAt(fIdx++, dummy.matrix);
            // Store grid coord in userData for heatmap mapping if needed, but InstancedMesh doesn't support userData per instance easily.
            // We will map index back to coord if needed, or just iterate grid again for heatmap.
          }
        }
      }

      scene.add(wallInstancedMesh);
      scene.add(floorInstancedMesh);

      // Adjust Camera
      if (!isGameMode) {
        controls.target.set(0, 0, 0);
        camera.position.set(0, Math.max(m.gw, m.gh) * 1.2, Math.max(m.gw, m.gh) * 0.8);
        controls.update();
      }
    }

    // --- ALGORITHMS ---

    async function runTask(fn) {
      if (abortController) abortController.abort();
      abortController = new AbortController();
      isGenerating = true;
      ui.status.innerText = "Running...";
      try {
        await fn(abortController.signal);
        ui.status.innerText = "Done";
      } catch (e) {
        if (e.name === 'AbortError') ui.status.innerText = "Stopped";
        else console.error(e);
      }
      isGenerating = false;
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    function rng() { return Math.random(); }

    // Generators
    async function generateMaze(signal) {
      const w = parseInt(ui.width.value);
      const h = parseInt(ui.height.value);
      maze = new Maze(w, h);

      // Initial render (full walls)
      renderMazeFull(maze);

      const algo = ui.genSelect.value;
      const speed = parseInt(ui.speed.value);

      // Helper to visualize
      let batch = 0;
      const updateVis = async () => {
        if (batch++ % speed === 0) {
          renderMazeFull(maze);
          await sleep(10);
        }
      };

      if (algo === 'dfs') await genDFS(maze, updateVis, signal);
      else if (algo === 'kruskal') await genKruskal(maze, updateVis, signal);
      else if (algo === 'prim') await genPrim(maze, updateVis, signal);
      else if (algo === 'wilson') await genWilson(maze, updateVis, signal);
      else if (algo === 'growing') await genGrowing(maze, updateVis, signal);
      else if (algo === 'caves') await genCaves(maze, updateVis, signal);

      renderMazeFull(maze);
      calcStats(maze);
    }

    async function genDFS(m, update, signal) {
      const stack = [[0, 0]];
      const visited = new Set(['0,0']);
      m.set(1, 1, 0); // Clear start

      while (stack.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        const [r, c] = stack[stack.length - 1];
        const nbrs = [];
        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
          const nr = r + dr, nc = c + dc;
          if (m.inBounds(nr, nc) && !visited.has(`${nr},${nc}`)) nbrs.push([nr, nc]);
        });

        if (nbrs.length > 0) {
          const [nr, nc] = nbrs[Math.floor(rng() * nbrs.length)];
          m.removeWall([r, c], [nr, nc]);
          visited.add(`${nr},${nc}`);
          stack.push([nr, nc]);
          await update();
        } else {
          stack.pop();
        }
      }
    }

    async function genPrim(m, update, signal) {
      const walls = [];
      const visited = new Set(['0,0']);
      m.set(1, 1, 0);

      [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
        const nr = 0 + dr, nc = 0 + dc;
        if (m.inBounds(nr, nc)) walls.push([[0, 0], [nr, nc]]);
      });

      while (walls.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        const idx = Math.floor(rng() * walls.length);
        const [p, n] = walls[idx];
        walls.splice(idx, 1);

        const nKey = `${n[0]},${n[1]}`;
        if (!visited.has(nKey)) {
          m.removeWall(p, n);
          visited.add(nKey);

          [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
            const nr = n[0] + dr, nc = n[1] + dc;
            if (m.inBounds(nr, nc) && !visited.has(`${nr},${nc}`)) {
              walls.push([n, [nr, nc]]);
            }
          });
          await update();
        }
      }
    }

    async function genWilson(m, update, signal) {
      const w = m.w, h = m.h;
      const unvisited = new Set();
      for (let r = 0; r < h; r++) for (let c = 0; c < w; c++) unvisited.add(`${r},${c}`);

      const first = [...unvisited][Math.floor(rng() * unvisited.size)];
      unvisited.delete(first);
      const [fr, fc] = first.split(',').map(Number);
      m.set(fr * 2 + 1, fc * 2 + 1, 0);

      while (unvisited.size > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        let u = [...unvisited][Math.floor(rng() * unvisited.size)];
        let [ur, uc] = u.split(',').map(Number);
        let currentPath = [[ur, uc]];

        while (unvisited.has(`${currentPath[currentPath.length - 1][0]},${currentPath[currentPath.length - 1][1]}`)) {
          let [lr, lc] = currentPath[currentPath.length - 1];
          const nbrs = [];
          [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
            const nr = lr + dr, nc = lc + dc;
            if (m.inBounds(nr, nc)) nbrs.push([nr, nc]);
          });
          const next = nbrs[Math.floor(rng() * nbrs.length)];

          const idx = currentPath.findIndex(p => p[0] === next[0] && p[1] === next[1]);
          if (idx !== -1) {
            currentPath = currentPath.slice(0, idx + 1);
          } else {
            currentPath.push(next);
          }
        }

        for (let i = 0; i < currentPath.length - 1; i++) {
          m.removeWall(currentPath[i], currentPath[i + 1]);
          unvisited.delete(`${currentPath[i][0]},${currentPath[i][1]}`);
          await update();
        }
        unvisited.delete(`${currentPath[currentPath.length - 1][0]},${currentPath[currentPath.length - 1][1]}`);
      }
    }

    async function genKruskal(m, update, signal) {
      const edges = [];
      for (let r = 0; r < m.h; r++) {
        for (let c = 0; c < m.w; c++) {
          if (r + 1 < m.h) edges.push([[r, c], [r + 1, c]]);
          if (c + 1 < m.w) edges.push([[r, c], [r, c + 1]]);
        }
      }
      for (let i = edges.length - 1; i > 0; i--) {
        const j = Math.floor(rng() * (i + 1));
        [edges[i], edges[j]] = [edges[j], edges[i]];
      }

      const parent = new Int32Array(m.w * m.h).fill(-1);
      const find = (i) => parent[i] < 0 ? i : (parent[i] = find(parent[i]));
      const union = (i, j) => {
        const rootI = find(i), rootJ = find(j);
        if (rootI !== rootJ) { parent[rootJ] = rootI; return true; }
        return false;
      };

      for (const [u, v] of edges) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        const uIdx = u[0] * m.w + u[1];
        const vIdx = v[0] * m.w + v[1];
        if (union(uIdx, vIdx)) {
          m.removeWall(u, v);
          await update();
        }
      }
    }

    async function genGrowing(m, update, signal) {
      const visited = new Set(['0,0']);
      const active = [[0, 0]];
      m.set(1, 1, 0);

      while (active.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');

        const idx = (rng() > 0.5) ? active.length - 1 : Math.floor(rng() * active.length);
        const [r, c] = active[idx];

        const nbrs = [];
        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
          const nr = r + dr, nc = c + dc;
          if (m.inBounds(nr, nc) && !visited.has(`${nr},${nc}`)) nbrs.push([nr, nc]);
        });

        if (nbrs.length > 0) {
          const [nr, nc] = nbrs[Math.floor(rng() * nbrs.length)];
          m.removeWall([r, c], [nr, nc]);
          visited.add(`${nr},${nc}`);
          active.push([nr, nc]);
          await update();
        } else {
          active.splice(idx, 1);
        }
      }
    }

    async function genCaves(m, update, signal) {
      // Cellular Automata
      // 1. Random fill
      for (let r = 1; r < m.gh - 1; r++) {
        for (let c = 1; c < m.gw - 1; c++) {
          m.set(r, c, (rng() < 0.45) ? 1 : 0);
        }
      }
      await update();

      // 2. Smoothing
      const iterations = 5;
      for (let i = 0; i < iterations; i++) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        const nextGrid = new Int8Array(m.data);
        for (let r = 1; r < m.gh - 1; r++) {
          for (let c = 1; c < m.gw - 1; c++) {
            let walls = 0;
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                if (m.get(r + dr, c + dc) === 1) walls++;
              }
            }
            if (walls > 4) nextGrid[r * m.gw + c] = 1;
            else if (walls < 4) nextGrid[r * m.gw + c] = 0;
          }
        }
        m.data = nextGrid;
        await update();
      }
    }

    // Solvers
    async function solveMaze(signal) {
      if (!maze) return;
      pathMeshGroup.clear();

      const algo = ui.solveSelect.value;
      // Find valid start/goal for caves
      let start = [1, 1];
      let goal = [maze.gh - 2, maze.gw - 2];

      // Search for valid start/goal if current are walls
      if (maze.get(start[0], start[1]) !== 0) {
        for (let r = 1; r < maze.gh; r++) {
          for (let c = 1; c < maze.gw; c++) {
            if (maze.get(r, c) === 0) { start = [r, c]; break; }
          }
          if (maze.get(start[0], start[1]) === 0) break;
        }
      }
      if (maze.get(goal[0], goal[1]) !== 0) {
        for (let r = maze.gh - 2; r > 0; r--) {
          for (let c = maze.gw - 2; c > 0; c--) {
            if (maze.get(r, c) === 0) { goal = [r, c]; break; }
          }
          if (maze.get(goal[0], goal[1]) === 0) break;
        }
      }

      let path = [];
      if (algo === 'bfs') path = await bfs(maze, start, goal, signal);
      else if (algo === 'astar') path = await astar(maze, start, goal, signal);
      else if (algo === 'bibfs') path = await bibfs(maze, start, goal, signal);
      else if (algo === 'dijkstra') path = await bfs(maze, start, goal, signal);

      if (path) drawPath3D(path);
      ui.pathLen.innerText = path ? path.length : "No Path";
    }

    async function bfs(m, start, goal, signal) {
      const q = [start];
      const parent = new Map();
      parent.set(start.toString(), null);
      const visited = new Set([start.toString()]);
      const speed = parseInt(ui.speed.value);
      let count = 0;

      while (q.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        const curr = q.shift();
        if (curr[0] === goal[0] && curr[1] === goal[1]) return reconstruct(parent, curr);

        const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dr, dc] of nbrs) {
          const nr = curr[0] + dr, nc = curr[1] + dc;
          const key = `${nr},${nc}`;
          if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !visited.has(key)) {
            visited.add(key);
            parent.set(key, curr);
            q.push([nr, nc]);
            if (count++ % speed === 0) { drawPoint(nr, nc, 0x06b6d4); await sleep(5); }
          }
        }
      }
      return null;
    }

    async function astar(m, start, goal, signal) {
      const open = [{ pos: start, f: 0, g: 0 }];
      const parent = new Map();
      const visited = new Set();
      const h = (a, b) => Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);
      const speed = parseInt(ui.speed.value);
      let count = 0;

      while (open.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        open.sort((a, b) => a.f - b.f);
        const { pos: curr, g } = open.shift();
        const key = curr.toString();
        if (visited.has(key)) continue;
        visited.add(key);
        if (curr[0] === goal[0] && curr[1] === goal[1]) return reconstruct(parent, curr);

        const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
        for (const [dr, dc] of nbrs) {
          const nr = curr[0] + dr, nc = curr[1] + dc;
          const nKey = `${nr},${nc}`;
          if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !visited.has(nKey)) {
            parent.set(nKey, curr);
            open.push({ pos: [nr, nc], g: g + 1, f: g + 1 + h([nr, nc], goal) });
            if (count++ % speed === 0) { drawPoint(nr, nc, 0x8b5cf6); await sleep(5); }
          }
        }
      }
      return null;
    }

    async function bibfs(m, start, goal, signal) {
      const q1 = [start], q2 = [goal];
      const p1 = new Map([[start.toString(), null]]);
      const p2 = new Map([[goal.toString(), null]]);
      const v1 = new Set([start.toString()]);
      const v2 = new Set([goal.toString()]);
      const speed = parseInt(ui.speed.value);
      let count = 0;

      while (q1.length > 0 && q2.length > 0) {
        if (signal.aborted) throw new DOMException('Aborted', 'AbortError');
        if (q1.length > 0) {
          const c1 = q1.shift();
          const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          for (const [dr, dc] of nbrs) {
            const nr = c1[0] + dr, nc = c1[1] + dc;
            const key = `${nr},${nc}`;
            if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !v1.has(key)) {
              v1.add(key);
              p1.set(key, c1);
              q1.push([nr, nc]);
              if (v2.has(key)) return mergePaths(p1, p2, [nr, nc]);
              if (count++ % speed === 0) { drawPoint(nr, nc, 0x06b6d4); await sleep(5); }
            }
          }
        }
        if (q2.length > 0) {
          const c2 = q2.shift();
          const nbrs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          for (const [dr, dc] of nbrs) {
            const nr = c2[0] + dr, nc = c2[1] + dc;
            const key = `${nr},${nc}`;
            if (nr >= 0 && nr < m.gh && nc >= 0 && nc < m.gw && m.get(nr, nc) === 0 && !v2.has(key)) {
              v2.add(key);
              p2.set(key, c2);
              q2.push([nr, nc]);
              if (v1.has(key)) return mergePaths(p1, p2, [nr, nc]);
              if (count++ % speed === 0) { drawPoint(nr, nc, 0xf43f5e); await sleep(5); }
            }
          }
        }
      }
      return null;
    }

    function reconstruct(parent, end) {
      const path = [end];
      let curr = end;
      while (parent.get(curr.toString())) {
        curr = parent.get(curr.toString());
        path.push(curr);
      }
      return path.reverse();
    }

    function mergePaths(p1, p2, meet) {
      const path1 = reconstruct(p1, meet);
      const path2 = reconstruct(p2, meet);
      return path1.slice(0, -1).concat(path2.reverse());
    }

    // --- HEATMAP ---
    async function showHeatmap() {
      if (!maze || !floorInstancedMesh) return;

      // BFS from valid start
      let start = [1, 1];
      if (maze.get(start[0], start[1]) !== 0) {
        for (let r = 1; r < maze.gh; r++) for (let c = 1; c < maze.gw; c++) if (maze.get(r, c) === 0) { start = [r, c]; break; }
      }

      const dists = new Int32Array(maze.gw * maze.gh).fill(-1);
      const q = [start];
      dists[start[0] * maze.gw + start[1]] = 0;
      let maxDist = 0;

      while (q.length > 0) {
        const [r, c] = q.shift();
        const d = dists[r * maze.gw + c];
        if (d > maxDist) maxDist = d;

        [[0, 1], [0, -1], [1, 0], [-1, 0]].forEach(([dr, dc]) => {
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < maze.gh && nc >= 0 && nc < maze.gw && maze.get(nr, nc) === 0 && dists[nr * maze.gw + nc] === -1) {
            dists[nr * maze.gw + nc] = d + 1;
            q.push([nr, nc]);
          }
        });
      }

      // Update colors
      let fIdx = 0;
      const color = new THREE.Color();
      for (let r = 0; r < maze.gh; r++) {
        for (let c = 0; c < maze.gw; c++) {
          if (maze.get(r, c) === 0) {
            const d = dists[r * maze.gw + c];
            if (d !== -1) {
              const t = d / maxDist;
              color.setHSL(0.6 - t * 0.6, 1, 0.5); // Blue to Red
            } else {
              color.setHex(0x0f172a);
            }
            floorInstancedMesh.setColorAt(fIdx++, color);
          }
        }
      }
      floorInstancedMesh.instanceColor.needsUpdate = true;
    }

    // --- VISUALIZATION HELPERS ---
    function drawPoint(r, c, color) {
      const geo = new THREE.BoxGeometry(CELL_SIZE * 0.8, 0.5, CELL_SIZE * 0.8);
      const mat = new THREE.MeshBasicMaterial({ color: color });
      const mesh = new THREE.Mesh(geo, mat);
      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;
      mesh.position.set(c * CELL_SIZE + offsetX, 0.5, r * CELL_SIZE + offsetZ);
      pathMeshGroup.add(mesh);
    }

    function drawPath3D(path) {
      const points = [];
      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;

      path.forEach(([r, c]) => {
        points.push(new THREE.Vector3(c * CELL_SIZE + offsetX, 1, r * CELL_SIZE + offsetZ));
      });

      const curve = new THREE.CatmullRomCurve3(points);
      const geo = new THREE.TubeGeometry(curve, path.length * 2, 0.2, 8, false);
      const mat = new THREE.MeshStandardMaterial({ color: 0x10b981, emissive: 0x10b981, emissiveIntensity: 0.5 });
      const mesh = new THREE.Mesh(geo, mat);
      pathMeshGroup.add(mesh);
    }

    function calcStats(m) {
      let deadEnds = 0;
      let passages = 0;
      for (let r = 1; r < m.gh - 1; r++) {
        for (let c = 1; c < m.gw - 1; c++) {
          if (m.get(r, c) === 0) {
            passages++;
            let exits = 0;
            if (m.get(r + 1, c) === 0) exits++;
            if (m.get(r - 1, c) === 0) exits++;
            if (m.get(r, c + 1) === 0) exits++;
            if (m.get(r, c - 1) === 0) exits++;
            if (exits === 1) deadEnds++;
          }
        }
      }
      ui.cells.innerText = passages;
      ui.deadEnds.innerText = passages ? Math.round((deadEnds / passages) * 100) + '%' : '0%';
    }

    // --- GAME LOGIC ---
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const moveState = { fwd: false, bwd: false, left: false, right: false, run: false };

    document.addEventListener('keydown', (e) => {
      switch (e.code) {
        case 'KeyW': moveState.fwd = true; break;
        case 'KeyS': moveState.bwd = true; break;
        case 'KeyA': moveState.left = true; break;
        case 'KeyD': moveState.right = true; break;
        case 'ShiftLeft': moveState.run = true; break;
      }
    });
    document.addEventListener('keyup', (e) => {
      switch (e.code) {
        case 'KeyW': moveState.fwd = false; break;
        case 'KeyS': moveState.bwd = false; break;
        case 'KeyA': moveState.left = false; break;
        case 'KeyD': moveState.right = false; break;
        case 'ShiftLeft': moveState.run = false; break;
      }
    });

    function updateGameLogic() {
      if (!isGameMode) return;

      const delta = 0.015;
      const speed = moveState.run ? 15.0 : 8.0;

      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;

      direction.z = Number(moveState.fwd) - Number(moveState.bwd);
      direction.x = Number(moveState.right) - Number(moveState.left);
      direction.normalize();

      if (moveState.fwd || moveState.bwd) velocity.z -= direction.z * speed * 10.0 * delta;
      if (moveState.left || moveState.right) velocity.x -= direction.x * speed * 10.0 * delta;

      fpsControls.moveRight(-velocity.x * delta);
      fpsControls.moveForward(-velocity.z * delta);

      const pos = camera.position;
      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;

      const gx = Math.round((pos.x - offsetX) / CELL_SIZE);
      const gz = Math.round((pos.z - offsetZ) / CELL_SIZE);

      if (gx < 0 || gx >= maze.gw || gz < 0 || gz >= maze.gh || maze.get(gz, gx) === 1) {
        camera.position.x -= -velocity.x * delta;
        camera.position.z -= -velocity.z * delta;
        velocity.set(0, 0, 0);
      }

      const goalX = maze.gw - 2;
      const goalZ = maze.gh - 2;
      if (Math.abs(gx - goalX) < 2 && Math.abs(gz - goalZ) < 2) {
        ui.gameOverlay.style.display = 'block';
        document.exitPointerLock();
        isGameMode = false;
        updateFog();
      }
    }

    window.exitGameMode = () => {
      ui.gameOverlay.style.display = 'none';
      isGameMode = false;
      updateFog();
      controls.target.set(0, 0, 0);
      camera.position.set(0, 40, 40);
      controls.update();
    };

    // --- EVENTS ---
    document.getElementById('genBtn').onclick = () => runTask(generateMaze);
    document.getElementById('stopBtn').onclick = () => { if (abortController) abortController.abort(); };
    document.getElementById('solveBtn').onclick = () => runTask(solveMaze);
    document.getElementById('heatmapBtn').onclick = () => showHeatmap();
    document.getElementById('clearBtn').onclick = () => { pathMeshGroup.clear(); floorInstancedMesh.instanceColor = null; floorInstancedMesh.setColorAt(0, new THREE.Color(0x0f172a)); renderMazeFull(maze); };

    document.getElementById('viewOrbit').onclick = () => {
      isGameMode = false;
      document.exitPointerLock();
      controls.enabled = true;
      updateFog();
    };
    document.getElementById('viewFPS').onclick = () => {
      if (!maze) return;
      isGameMode = true;
      controls.enabled = false;

      let start = [1, 1];
      if (maze.get(1, 1) !== 0) {
        for (let r = 1; r < maze.gh; r++) for (let c = 1; c < maze.gw; c++) if (maze.get(r, c) === 0) { start = [r, c]; break; }
      }

      const offsetX = -(maze.gw * CELL_SIZE) / 2;
      const offsetZ = -(maze.gh * CELL_SIZE) / 2;
      camera.position.set(start[1] * CELL_SIZE + offsetX, 1.5, start[0] * CELL_SIZE + offsetZ);

      fpsControls.lock();
    };

    document.getElementById('togglePanelBtn').onclick = () => {
      document.getElementById('mainPanel').classList.toggle('collapsed');
    };

    // Init
    init3D();
    runTask(generateMaze);

  </script>
</body>

</html>