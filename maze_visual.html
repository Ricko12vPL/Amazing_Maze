<!doctype html>
<html lang="pl">
<head>
<meta charset="utf-8" />
<title>Interaktywny labirynt — generator + solver (animacja) — poprawiony</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  :root{
    --bg:#0b0b0c;
    --panel:#0f1720;
    --muted:#9aa4b2;
    --accent:#16a34a;
    --accent2:#2563eb;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef6;font-family:Inter,Segoe UI,Arial,sans-serif}
  .wrap{display:flex;gap:12px;padding:12px;height:100%;box-sizing:border-box}
  .panel{width:320px;background:linear-gradient(180deg,var(--panel),#0b1220);border-radius:10px;padding:12px;box-shadow:0 6px 30px rgba(0,0,0,0.6)}
  .panel h2{margin:6px 0 10px 0;font-size:18px;color:white}
  label{display:flex;justify-content:space-between;align-items:center;margin:8px 0;font-size:13px;color:var(--muted)}
  input[type=number], select {width:130px;padding:6px;border-radius:6px;border:1px solid #1f2937;background:#06111a;color:#dbeafe}
  button{display:inline-block;background:var(--accent);color:white;border:none;padding:8px 10px;border-radius:8px;margin:6px 4px;cursor:pointer}
  button.secondary{background:#374151}
  .small{font-size:12px;color:var(--muted);margin-top:6px}
  canvas{border-radius:10px;background:#071022;box-shadow: 0 10px 40px rgba(0,0,0,0.8)}
  .footer{font-size:12px;color:var(--muted);margin-top:8px}
  .row{display:flex;gap:8px;align-items:center}
  .toggle{display:flex;gap:6px;align-items:center}
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h2>Labirynt — generator & solver (poprawiony)</h2>

    <label>Rozmiar (szer. komórki) <input id="cellsInput" type="number" value="40" min="6" max="160" /></label>
    <label>Wysokość (komórki) <input id="rowsInput" type="number" value="28" min="6" max="120" /></label>

    <label>Kształt
      <select id="shapeSelect">
        <option value="rect">Prostokąt</option>
        <option value="circle">Koło (maska)</option>
      </select>
    </label>

    <label>Generator
      <select id="genSelect">
        <option value="dfs">Recursive Backtracker (DFS)</option>
        <option value="growing">Growing Tree (mix)</option>
        <option value="kruskal">Kruskal (Union-Find)</option>
      </select>
    </label>

    <label>Strategia Growing Tree (p dla last) <input id="mixP" type="number" value="0.9" min="0" max="1" step="0.05" /></label>

    <label>Prędkość animacji <input id="speed" type="number" value="1" min="0.1" max="10" step="0.1" /></label>

    <div class="row">
      <button id="genBtn">Generuj</button>
      <button id="pauseBtn" class="secondary">Pauza</button>
    </div>

    <div class="row">
      <button id="solveBtn">Rozwiąż (BFS)</button>
      <button id="solveAstarBtn">Rozwiąż (A*)</button>
    </div>

    <div class="row">
      <button id="addLoopsBtn" class="secondary">Dodaj pętle</button>
      <button id="exportBtn" class="secondary">Eksportuj SVG</button>
    </div>

    <div class="small">Kliknij canvas, aby ustawić start (pierwszy klik) i koniec (drugi klik). Domyślnie wejście = górna otwarta komórka, wyjście = dolna.</div>
    <div class="footer">Poprawka: algorytm DFS teraz łączy wszystkie dozwolone komórki (obsługa masek).</div>
  </div>

  <div style="flex:1;display:flex;flex-direction:column;gap:12px;align-items:center">
    <canvas id="canvas" width="1200" height="800"></canvas>
    <div style="display:flex;gap:12px;color:var(--muted);font-size:13px">
      <div id="stats">Status: gotowy</div>
      <div id="metrics"></div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', {alpha:false});
let cw = canvas.width, ch = canvas.height;

const cellsInput = document.getElementById('cellsInput');
const rowsInput = document.getElementById('rowsInput');
const shapeSelect = document.getElementById('shapeSelect');
const genSelect = document.getElementById('genSelect');
const mixP = document.getElementById('mixP');
const speedInput = document.getElementById('speed');

const genBtn = document.getElementById('genBtn');
const pauseBtn = document.getElementById('pauseBtn');
const solveBtn = document.getElementById('solveBtn');
const solveAstarBtn = document.getElementById('solveAstarBtn');
const addLoopsBtn = document.getElementById('addLoopsBtn');
const exportBtn = document.getElementById('exportBtn');

const statsEl = document.getElementById('stats');
const metricsEl = document.getElementById('metrics');

let maze = null;
let paused = false;
let cellSize = 18;
let startGrid = null;
let goalGrid = null;

function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function rng(){ return Math.random(); }

class Maze {
  constructor(w,h,maskFunc=null){
    this.w = w; this.h = h;
    this.grid_h = 2*h + 1; this.grid_w = 2*w + 1;
    this.grid = Array.from({length:this.grid_h}, ()=>Array(this.grid_w).fill(1));
    this.mask = maskFunc;
    this.cells = [];
    for(let r=0;r<h;r++){
      for(let c=0;c<w;c++){
        if(!this.mask || this.mask(r,c)){
          const gr = r*2+1, gc = c*2+1;
          this.grid[gr][gc] = 0;
          this.cells.push([r,c]);
        }
      }
    }
  }
  inBoundsCell(r,c){ return r>=0 && r<this.h && c>=0 && c<this.w && (!this.mask || this.mask(r,c)); }
  cellToGrid(r,c){ return [r*2+1, c*2+1]; }
  removeWallBetween(a,b){
    const [ar,ac]=a, [br,bc]=b;
    const [gar,gac]=this.cellToGrid(ar,ac), [gbr,gbc]=this.cellToGrid(br,bc);
    const wr = (gar+gbr)/2 | 0, wc = (gac+gbc)/2 | 0;
    this.grid[wr][wc] = 0;
  }
}

// Drawing
function drawMaze(m, highlightSet=null, path=null){
  ctx.clearRect(0,0,cw,ch);
  ctx.fillStyle = '#071022';
  ctx.fillRect(0,0,cw,ch);
  if(!m) return;
  const H = m.grid_h, W = m.grid_w;
  const pad = 6;
  const maxCell = Math.floor(Math.min((cw - pad*2) / W, (ch - pad*2) / H));
  const cs = Math.max(4, Math.min(cellSize, maxCell));
  const ox = Math.floor((cw - W*cs)/2);
  const oy = Math.floor((ch - H*cs)/2);

  for(let r=0;r<H;r++){
    for(let c=0;c<W;c++){
      const v = m.grid[r][c];
      const x = ox + c*cs, y = oy + r*cs;
      if(v===1){
        ctx.fillStyle = '#02111a';
        ctx.fillRect(x,y,cs,cs);
      } else {
        ctx.fillStyle = '#e6eef6';
        ctx.fillRect(x,y,cs,cs);
      }
    }
  }
  if(highlightSet){
    for(const k of highlightSet){
      const [r,c]=k.split(',').map(Number);
      ctx.fillStyle = 'rgba(37,99,235,0.14)';
      ctx.fillRect(ox + c*cs, oy + r*cs, cs, cs);
    }
  }
  if(path){
    for(const [r,c] of path){
      ctx.fillStyle = 'rgba(255,0,0,0.9)';
      ctx.fillRect(ox + c*cs + cs*0.15, oy + r*cs + cs*0.15, cs*0.7, cs*0.7);
    }
  }
  if(startGrid){
    const [sr,sc] = startGrid;
    ctx.fillStyle = '#16a34a';
    ctx.fillRect(ox + sc*cs, oy + sr*cs, cs, cs);
  }
  if(goalGrid){
    const [gr,gc] = goalGrid;
    ctx.fillStyle = '#2563eb';
    ctx.fillRect(ox + gc*cs, oy + gr*cs, cs, cs);
  }
}

// Utility shuffle
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]]=[arr[j],arr[i]];
  }
}

// throttling
function throttle(speedFactor){
  const base = 8;
  const mv = Math.max(0.05, speedFactor);
  return sleep(base / mv);
}

/* ====== POPRAWIONA FUNKCJA GENERUJĄCA (DFS / Growing Tree) ======
   Uwaga: obsługuje maski. Gwarantuje, że wszystkie dozwolone komórki
   zostaną połączone (łączenie komponentów) — dzięki temu labirynt
   będzie spójny / rozwiązywalny, o ile wejście/wyjście leżą w tym
   spójnym obszarze.
*/
async function generateDFS_fullcoverage(m, speedFactor=1, strategy='last'){
  statsEl.textContent = 'Status: generowanie (DFS / Growing Tree)...';
  const visited = new Set();
  if(!m || m.cells.length===0) return;

  // pomoc: zbiór wszystkich cell-key
  const keyOf = (cell)=> `${cell[0]},${cell[1]}`;

  // start z losowej komórki
  let startCell = m.cells[Math.floor(rng()*m.cells.length)];
  const stack = [startCell];
  visited.add(keyOf(startCell));
  const highlights = new Set();

  while((stack.length > 0 || visited.size < m.cells.length) && !paused){
    if(stack.length === 0){
      // są nieodwiedzone komórki — wybierz jedną losową i połącz z odwiedzonym sąsiadem (jeśli taki istnieje)
      const unvisited = m.cells.filter(c => !visited.has(keyOf(c)));
      const next = unvisited[Math.floor(rng()*unvisited.length)];
      // znajdź odwiedzonych sąsiadów next
      const nbrsVisited = [];
      for(const d of [[-1,0],[1,0],[0,-1],[0,1]]){
        const nr = next[0]+d[0], nc = next[1]+d[1];
        if(m.inBoundsCell(nr,nc) && visited.has(`${nr},${nc}`)){
          nbrsVisited.push([nr,nc]);
        }
      }
      if(nbrsVisited.length > 0){
        // połącz z losowym odwiedzonym sąsiadem, żeby zachować spójność
        const chosen = nbrsVisited[Math.floor(rng()*nbrsVisited.length)];
        m.removeWallBetween(chosen, next);
        visited.add(keyOf(next));
        stack.push(next);
        highlights.add(keyOf(chosen));
        highlights.add(keyOf(next));
      } else {
        // brak odwiedzonych sąsiadów (izolowany fragment maski) — po prostu zacznij nowy "drzewo"
        visited.add(keyOf(next));
        stack.push(next);
        highlights.add(keyOf(next));
      }
      drawMaze(m, highlights);
      await throttle(speedFactor * 0.8);
      continue;
    }

    // wybór komórki ze stosu wg strategii
    let idx;
    if(typeof strategy === 'number'){
      idx = (rng() < strategy) ? stack.length-1 : Math.floor(rng()*stack.length);
    } else if(strategy === 'last') idx = stack.length-1;
    else if(strategy === 'random') idx = Math.floor(rng()*stack.length);
    else if(strategy === 'first') idx = 0;
    else idx = stack.length-1;

    const cell = stack[idx];
    const [r,c] = cell;
    // znajdź nieodwiedzonych sąsiadów
    const neighbors = [];
    for(const d of [[-1,0],[1,0],[0,-1],[0,1]]){
      const nr = r + d[0], nc = c + d[1];
      if(m.inBoundsCell(nr,nc) && !visited.has(`${nr},${nc}`)){
        neighbors.push([nr,nc]);
      }
    }
    if(neighbors.length > 0){
      const nb = neighbors[Math.floor(rng()*neighbors.length)];
      m.removeWallBetween([r,c], nb);
      visited.add(keyOf(nb));
      stack.push(nb);
      highlights.add(keyOf(nb));
      highlights.add(keyOf([r,c]));
    } else {
      stack.splice(idx,1);
    }
    // rysuj fragmenty podczas pracy
    if(Math.random() < 0.08) drawMaze(m, highlights);
    await throttle(speedFactor);
  }

  drawMaze(m);
  statsEl.textContent = 'Status: wygenerowano (DFS pełne pokrycie)';
}

/* ====== KRUSKAL ====== (jest OK; zostawiam prawie bez zmian) */
async function generateKruskal(m, speedFactor=1){
  statsEl.textContent = 'Status: generowanie (Kruskal)...';
  const edges = [];
  for(const [r,c] of m.cells){
    [[0,1],[1,0]].forEach(d=>{
      const nr=r+d[0], nc=c+d[1];
      if(m.inBoundsCell(nr,nc)) edges.push([[r,c],[nr,nc]]);
    });
  }
  shuffle(edges);
  const parent = new Map();
  for(const cell of m.cells) parent.set(cell.join(','), cell.join(','));
  function find(u){
    let p = parent.get(u);
    if(p !== u){
      p = find(p);
      parent.set(u,p);
    }
    return p;
  }
  function union(a,b){
    const ra = find(a), rb = find(b);
    if(ra === rb) return false;
    parent.set(rb, ra);
    return true;
  }
  const highlights = new Set();
  for(const [a,b] of edges){
    if(paused) { await throttle(speedFactor*0.5); continue; }
    const ak = a.join(','), bk = b.join(',');
    if(union(ak, bk)){
      m.removeWallBetween(a,b);
      highlights.add(ak); highlights.add(bk);
    }
    if(Math.random() < 0.03) drawMaze(m, highlights);
    await throttle(speedFactor * 0.4);
  }
  drawMaze(m);
  statsEl.textContent = 'Status: wygenerowano (Kruskal)';
}

/* ====== SOLVERY (BFS + A*) - bez zmian logicznych, ale dodane komunikaty) ====== */
async function bfsSolve(m, speedFactor=1){
  if(!m){ statsEl.textContent='Brak labiryntu'; return; }
  if(!startGrid || !goalGrid){ statsEl.textContent='Ustaw start i cel (kliknij canvas)'; return; }
  statsEl.textContent = 'Status: rozwiązywanie (BFS)...';
  const H=m.grid_h, W=m.grid_w;
  const start = startGrid, goal = goalGrid;
  const q=[]; q.push(start);
  const parent = new Map();
  parent.set(start.join(','), null);
  const visited = new Set();
  visited.add(start.join(','));
  const highlights = new Set();

  while(q.length && !paused){
    const cur = q.shift();
    if(cur[0]===goal[0] && cur[1]===goal[1]) break;
    for(const d of [[-1,0],[1,0],[0,-1],[0,1]]){
      const nr = cur[0]+d[0], nc = cur[1]+d[1];
      if(nr>=0 && nr<H && nc>=0 && nc<W && m.grid[nr][nc]===0){
        const key = `${nr},${nc}`;
        if(!parent.has(key)){
          parent.set(key, cur.join(','));
          q.push([nr,nc]);
          highlights.add(key);
        }
      }
    }
    if(Math.random() < 0.04) drawMaze(m, highlights);
    await throttle(speedFactor*0.7);
  }

  const goalKey = goal.join(',');
  if(!parent.has(goalKey)){ statsEl.textContent='Brak ścieżki (niepołączone komponenty?)'; return; }
  const path=[];
  let key = goalKey;
  while(key){
    const [rr,cc] = key.split(',').map(Number);
    path.push([rr,cc]);
    key = parent.get(key);
  }
  path.reverse();
  statsEl.textContent = 'Status: odnaleziono trasę (BFS)';
  for(let i=0;i<path.length && !paused;i++){
    drawMaze(m, null, path.slice(0,i+1));
    await throttle(speedFactor*2);
  }
  drawMaze(m, null, path);
}

function heuristic(a,b){ return Math.abs(a[0]-b[0]) + Math.abs(a[1]-b[1]); }
async function aStarSolve(m, speedFactor=1){
  if(!m){ statsEl.textContent='Brak labiryntu'; return; }
  if(!startGrid || !goalGrid){ statsEl.textContent='Ustaw start i cel (kliknij canvas)'; return; }
  statsEl.textContent = 'Status: rozwiązywanie (A*)...';
  const H=m.grid_h, W=m.grid_w;
  const start = startGrid, goal = goalGrid;
  const keyStart = start.join(','), keyGoal = goal.join(',');
  const open = new Set(); open.add(keyStart);
  const g = new Map(); const f = new Map(); const parent = new Map();
  g.set(keyStart, 0); f.set(keyStart, heuristic(start,goal));

  const visited = new Set();
  while(open.size && !paused){
    // wybierz najlepsze f
    let curKey = null, best = Infinity;
    for(const k of open){
      const fv = f.get(k) ?? Infinity;
      if(fv < best){ best = fv; curKey = k; }
    }
    if(curKey === keyGoal) break;
    open.delete(curKey);
    visited.add(curKey);
    const [r,c] = curKey.split(',').map(Number);
    for(const d of [[-1,0],[1,0],[0,-1],[0,1]]){
      const nr=r+d[0], nc=c+d[1];
      if(nr>=0 && nr<H && nc>=0 && nc<W && m.grid[nr][nc]===0){
        const k2 = `${nr},${nc}`;
        const tentative = (g.get(curKey)||Infinity) + 1;
        if(tentative < (g.get(k2)||Infinity)){
          parent.set(k2, curKey);
          g.set(k2, tentative);
          f.set(k2, tentative + heuristic([nr,nc], goal));
          open.add(k2);
        }
      }
    }
    if(Math.random() < 0.04) drawMaze(m, visited);
    await throttle(speedFactor*0.9);
  }

  if(!parent.has(keyGoal) && keyStart !== keyGoal){ statsEl.textContent='Brak ścieżki (A*)'; return; }
  // odtwórz ścieżkę (jeśli start==goal, to zwróci jedynie ten punkt)
  const path=[]; let k = keyGoal;
  while(k){
    path.unshift(k.split(',').map(Number));
    k = parent.get(k);
  }
  statsEl.textContent = 'Status: odnaleziono trasę (A*)';
  for(let i=0;i<path.length && !paused;i++){
    drawMaze(m, null, path.slice(0,i+1));
    await throttle(speedFactor*2);
  }
  drawMaze(m, null, path);
}

/* ====== Dodawanie pętli i eksport SVG (jak wcześniej) ====== */
function addLoops(m, percent=0.02){
  const H=m.grid_h, W=m.grid_w;
  let removed=0;
  for(let r=1;r<H-1;r++){
    for(let c=1;c<W-1;c++){
      if(m.grid[r][c]===1 && Math.random() < percent){
        const neighPass = (m.grid[r-1][c]===0) + (m.grid[r+1][c]===0) + (m.grid[r][c-1]===0) + (m.grid[r][c+1]===0);
        if(neighPass>=2 && neighPass<=3){
          m.grid[r][c]=0; removed++;
        }
      }
    }
  }
  return removed;
}

function exportSVG(m){
  if(!m) return;
  const H=m.grid_h, W=m.grid_w;
  const cs = 6;
  const width = W*cs, height = H*cs;
  let svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">`;
  svg += `<rect width="100%" height="100%" fill="#071022"/>`;
  for(let r=0;r<H;r++){
    for(let c=0;c<W;c++){
      if(m.grid[r][c]===1){
        svg += `<rect x="${c*cs}" y="${r*cs}" width="${cs}" height="${cs}" fill="#02111a"/>`;
      }
    }
  }
  svg += `</svg>`;
  const blob = new Blob([svg], {type:'image/svg+xml'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'maze.svg'; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);
}

/* ====== Interakcje canvas ====== */
canvas.addEventListener('click', (ev)=>{
  if(!maze) return;
  const rect = canvas.getBoundingClientRect();
  const x = ev.clientX - rect.left, y = ev.clientY - rect.top;
  const H=maze.grid_h, W=maze.grid_w;
  const maxCell = Math.floor(Math.min((cw - 12) / W, (ch - 12) / H));
  const cs = Math.max(4, Math.min(cellSize, maxCell));
  const ox = Math.floor((cw - W*cs)/2);
  const oy = Math.floor((ch - H*cs)/2);
  const gc = Math.floor((x - ox)/cs), gr = Math.floor((y - oy)/cs);
  if(gr>=0 && gr<H && gc>=0 && gc<W && maze.grid[gr][gc]===0){
    if(!startGrid || (startGrid && goalGrid)) { startGrid=[gr,gc]; goalGrid=null; }
    else if(startGrid && !goalGrid) goalGrid = [gr,gc];
    drawMaze(maze);
  }
});

/* ====== Kontrolki ====== */
genBtn.addEventListener('click', async ()=>{ paused=false; await startGeneration(); });
pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused ? 'Wznów' : 'Pauza'; statsEl.textContent = paused ? 'Status: pauza' : 'Status: działanie'; });
solveBtn.addEventListener('click', async ()=>{ paused=false; if(maze) await bfsSolve(maze, Number(speedInput.value)); });
solveAstarBtn.addEventListener('click', async ()=>{ paused=false; if(maze) await aStarSolve(maze, Number(speedInput.value)); });
addLoopsBtn.addEventListener('click', ()=>{ if(maze){ addLoops(maze, 0.02); drawMaze(maze); computeMetrics(); }});
exportBtn.addEventListener('click', ()=>{ if(maze) exportSVG(maze); });

/* ====== Orkiestrator generacji ====== */
async function startGeneration(){
  const w = Number(cellsInput.value)|0;
  const h = Number(rowsInput.value)|0;
  let mask = null;
  if(shapeSelect.value === 'circle'){
    const cx = (w-1)/2, cy = (h-1)/2, rad = Math.min(w,h)/2 - 0.5;
    mask = (r,c)=> {
      const dx = c - cx, dy = r - cy;
      return (dx*dx + dy*dy) <= (rad*rad);
    };
  }
  maze = new Maze(w,h,mask);
  cw = Math.min(window.innerWidth - 380, Math.max(600, w*18));
  ch = Math.min(window.innerHeight - 60, Math.max(360, h*18));
  canvas.width = cw; canvas.height = ch;

  drawMaze(maze);
  startGrid = null; goalGrid = null;

  const speedFactor = Number(speedInput.value) || 1;
  const gen = genSelect.value;
  paused = false;
  if(gen === 'dfs' || gen === 'growing'){
    const strategy = (gen==='growing') ? Number(mixP.value) : 'last';
    await generateDFS_fullcoverage(maze, speedFactor, strategy);
  } else if(gen === 'kruskal'){
    await generateKruskal(maze, speedFactor);
  }

  // ustawienie wejścia/wyjścia (górna i dolna otworzona komórka)
  for(let c=1;c<maze.grid_w-1;c++){
    if(maze.grid[1][c]===0){ startGrid=[0,c]; break; }
  }
  for(let c=maze.grid_w-2;c>0;c--){
    if(maze.grid[maze.grid_h-2][c]===0){ goalGrid=[maze.grid_h-1,c]; break; }
  }
  if(startGrid) maze.grid[startGrid[0]][startGrid[1]] = 0;
  if(goalGrid) maze.grid[goalGrid[0]][goalGrid[1]] = 0;
  drawMaze(maze);
  computeMetrics();
}

/* ====== Metryki ====== */
function computeMetrics(){
  if(!maze) return;
  const H=maze.grid_h, W=maze.grid_w;
  const centers = [];
  for(let r=1;r<H;r+=2) for(let c=1;c<W;c+=2) if(maze.grid[r][c]===0) centers.push([r,c]);
  if(centers.length===0){ metricsEl.textContent='Brak komórek.'; return; }
  const degs = [];
  for(const [r,c] of centers){
    let deg = 0;
    for(const d of [[-1,0],[1,0],[0,-1],[0,1]]){
      const nr=r+d[0], nc=c+d[1];
      if(nr>=0 && nr<H && nc>=0 && nc<W && maze.grid[nr][nc]===0) deg++;
    }
    degs.push(deg);
  }
  const dead = degs.filter(x=>x===1).length;
  const avgDeg = degs.reduce((a,b)=>a+b,0)/degs.length;
  metricsEl.textContent = `Komórek: ${centers.length}  Dead-ends: ${dead}  Śr. stopień: ${avgDeg.toFixed(2)}`;
}

/* ====== Start on load ====== */
window.addEventListener('load', ()=>{ startGeneration(); });

</script>
</body>
</html>
